---
marp: true
theme: default
paginate: true
size: 16:9
---

<style>
/* --- 布局辅助样式 --- */
.columns {
  display: grid;
  grid-template-columns: repeat(2, minmax(0, 1fr));
  gap: 1rem;
}
.columns pre code {
  white-space: pre-wrap !important;
  overflow-wrap: break-word !important;
}
/* --- 列表缩进样式修正 --- */
ul, ol {
  padding-inline-start: 25px; /* 减小列表的左侧缩进 */
}
.columns.ratio-4-6 { grid-template-columns: 4fr 6fr; }
.columns.ratio-6-4 { grid-template-columns: 6fr 4fr; }
.columns.ratio-3-7 { grid-template-columns: 3fr 7fr; }
.columns.ratio-7-3 { grid-template-columns: 7fr 3fr; }
.align-top    { display: flex; align-items: flex-start; }
.align-middle { display: flex; align-items: center; }
.align-bottom { display: flex; align-items: flex-end; }
.align-left   { display: flex; justify-content: flex-start; }
.align-center { display: flex; justify-content: center; }
.align-right  { display: flex; justify-content: flex-end; }
.align-top-left     { display: flex; justify-content: flex-start; align-items: flex-start; }
.align-top-center   { display: flex; justify-content: center;  align-items: flex-start; }
.align-top-right    { display: flex; justify-content: flex-end;   align-items: flex-start; }
.align-middle-left  { display: flex; justify-content: flex-start; align-items: center; }
.align-middle-center{ display: flex; justify-content: center;  align-items: center; }
.align-middle-right { display: flex; justify-content: flex-end;   align-items: center; }
.align-bottom-left  { display: flex; justify-content: flex-start; align-items: flex-end; }
.align-bottom-center{ display: flex; justify-content: center;  align-items: flex-end; }
.align-bottom-right { display: flex; justify-content: flex-end;   align-items: flex-end; }
.tip {
  background-color: #f0f8ff;
  border-left: 5px solid #1e90ff;
  padding: 15px 15px 0.1px; 
}
.insight {
  background-color: #eefcff; 
  border-left: 5px solid #17a2b8; 
  padding: 15px 15px 0.1px; 
}
.key-point {
  background-color: #fffbe6; 
  border-left: 5px solid #ffc107; 
  padding: 15px 15px 0.1px; 
}
.tip p, .tip li,
.insight p, .insight li,
.key-point p, .key-point li {
  font-size: inherit !important;
}
.styled-div p, 
.styled-div li, 
.styled-div ol, 
.styled-div ul, 
.styled-div blockquote {
  font-size: inherit !important;
}
</style>

![bg blur:3px brightness:60%](../../../lectures/images/2025-11-21-00-14-43.png)

<style scoped>
h1{
  color: #F5F5F5; /* 设置文字颜色为白色 */
  text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.8); /* 添加一个柔和的深色阴影 */
}
h2 {
  color: #E0E0E0; /* 设置文字颜色为白色 */
  text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.8); /* 添加一个柔和的深色阴影 */
}
.course-title {
  position: absolute;
  top: 60px;
  left: 80px;
  background-color: rgba(0, 0, 0, 0.4);
  color: #fff;
  padding: 8px 15px;
  border-radius: 5px;
  font-size: 22px;
  font-weight: bold;
  letter-spacing: 1px;
  border-left: 5px solid #4CAF50; /* 用一条强调色作为装饰 */
}
</style>

<div class="course-title">AI赋能软件开发</div>

# 模块三: 代码复用与人机协作
## 第12节课: 模块收官项目：批量文件整理助手

<div style="position: absolute; bottom: 40px; left: 80px; color: rgba(255, 255, 255, 0.8); font-size: 18px; font-family: sans-serif;">
南昌大学计算机系 黎鹰
</div>

<!--
各位老师好！欢迎来到我们模块三的最后一节课，也是我们的收官项目课！
今天，我们将综合运用本模块学到的所有高级技能，来完成一个非常实用的、能真正解决我们教学工作痛点的工具——批量文件整理助手。
让我们开始这次最终的试炼吧！
-->

---

## **回顾：你已是“AI开发主管”**

<div class="columns ratio-6-4">
<div style="font-size: 0.9em;">

在模块三的前三节课，我们作为“AI开发主管”，已经掌握了提升代码品质的核心方法，完成了从“能运行”到“高品质”的思维转变。

我们掌握了作为一名“**AI开发主管**”的全部核心技能：

- **封装与授权 (函数)**
  - 你能将混乱的逻辑打包成清晰的“功能积木”。
- **品控与纠错 (调试)**
  - 你能从容地将“事故报告”交给AI，并指导它修复问题。
- **评审与决策 (审查)**
  - 你能挑战AI，在多个方案中权衡利弊，做出最佳决策。

今天，我们将迎来对这些高级技能的**最终试炼**。

</div>
<div class="align-middle-center">

![一个充满自信的开发主管，站在白板前，指挥着一个AI机器人团队 width:400px](../../../lectures/images/2025-11-21-00-16-12.png)
</div>
</div>

<!--
在开始最终试炼之前，让我们先回顾一下，在本模块中，我们作为“AI开发主管”，实现了怎样的专业能力升级。
我们已经不再是那个只能写出“能运行就行”的代码的初级主管，而是掌握了三大核心“品质管理”要诀，向着专业迈出了一大步。
这三大要诀就是：
通过函数，我们学会了“封装与授权”，把任务分解打包。
通过调试，我们学会了“品控与纠错”，管理AI的失误。
通过代码审查，我们学会了“评审与决策”，在不同方案中做出权衡。
今天，就是对我们作为“AI开发主管”的全部核心素养的最终检验。
-->

---

## **项目使命：解决一个真实世界的“烦恼”**

<div class="columns ratio-6-4">
<div style="font-size: 0.8em;">

我们今天的项目，不再是构建虚拟世界，而是要解决一个老师们在日常工作中频繁遇到的真实烦恼：

**教学文件命名不统一**

想象一下你一个学期的教学资料文件夹，里面的文件名五花八门：
- `第1课.pptx`
- `学生名单-最新.xlsx`
- `课程总结.md`

当这些文件被传来传去，或从压缩包解压后，我们很难一眼看出它们属于哪个学期、哪门课程。

**我们的目标**：指挥AI编写一个“**批量文件重命名助手**”，一键为指定文件夹里的所有文件，都加上统一、清晰的前缀，例如 `2025秋-软件工程-`。

</div>
<div class="align-middle-center">

![一个文件列表，通过一个脚本，所有文件名前都加上了统一的前缀，例如“2025秋-软件工程-” width:400px](../../../lectures/images/2025-11-21-00-17-40.png)

</div>
</div>

<!--
我们今天的项目使命，非常明确。我们不再构建虚拟的武侠世界，而是要用我们学到的编程能力，解决一个在座各位老师都可能频繁遇到的真实烦恼——教学文件命名不统一。
大家可以想象一下自己的教学资料文件夹，是不是也像这样，文件名五花八门？当文件一多，或者传来传去，就完全乱了套。
所以，我们今天的目标，就是指挥AI，为我们打造一个“批量文件重命名助手”。它可以一键为指定文件夹里的所有文件，都加上一个统一、清晰的前缀，比如“2025秋-软件工程-”。
这是一个能让你在未来工作中，真正用得上、能提升效率的实用工具！
-->

---

## **第一步(1/2)：蓝图设计——明确输入与输出(IPO)**

在思考“如何做”之前，我们必须先彻底搞清楚“做什么”。一个专业的开发者，会花费大量时间来明确定义程序的**输入(Input)**和**输出(Output)**。

这就像做菜，你必须先弄清要用哪些食材（输入），以及最终想做出什么菜（输出），然后才能设计菜谱（处理流程）。

<div class="align-center">

![height:350px](../../../lectures/images/2025-11-21-12-23-55.png)

</div>

<!--
好，项目目标明确了。现在，我们以“AI开发主管”的身份，开始专业的设计流程。
在思考“如何做”之前，我们必须先彻底搞清楚“做什么”。一个专业的开发者，会先花时间明确定义程序的“输入”和“输出”。
这就像做菜，你得先想好需要哪些食材（输入），以及最终要做成什么菜（输出），然后才能去设计菜谱（也就是处理流程）。
对于我们的重命名助手，输入很明确：一个需要处理的“文件夹路径”，和一个要添加的“前缀字符串”。
输出也很明确：这个文件夹里的所有文件都被成功重命名。
中间的处理过程，我们可以把它想象成一个黑箱，暂时命名为`batch_rename_files`。
这个输入-处理-输出模型，也就是IPO模型，是程序设计最基础、最重要的思维框架。
-->

---

## **第一步(2/2)：蓝图设计——设计处理流程**

当我们清晰地定义了输入和输出后，就可以开始设计连接两者的“桥梁”——**处理流程 (Process)**。

<div class="columns">
<div style="font-size: 0.95em;">

**处理流程 (文字描述):**
1.  获取目标文件夹的路径和指定的前缀。
2.  遍历该文件夹中的**每一项**。
3.  构建该项的完整路径，并判断**如果**它是一个**文件**（而不是子文件夹）：
4.  构建出它的**新文件名** (前缀 + 原文件名)。
5.  构建出完整的新文件路径。
6.  将该文件从“旧的完整路径”**重命名**为“新的完整路径”。

</div>
<div class="align-center">

![width:165px](../../../lectures/images/2025-11-21-12-34-20.png)
</div>
</div>

<!--
输入和输出明确后，我们就可以来设计中间的“处理流程”了。
我们可以先用自然语言，像写操作手册一样，把步骤描述出来：
首先，获取文件夹路径和前缀。然后，遍历这个文件夹里的每一项。在遍历的过程中，我们需要判断，如果这一项是个文件，而不是子文件夹，那我们就为它构建一个新的文件名，然后执行重命名操作。如果不是文件，那就跳过，继续处理下一项。直到所有项都处理完毕，程序结束。
这个文字描述，就是我们算法的“伪代码”。
更进一步，我们可以把这个流程，用右边的“流程图”给画出来。流程图能更清晰地展示出程序中的“循环”和“判断”结构。
有了这份详细的蓝图，我们向AI下达指令时，就会胸有成竹。
-->

---

## **第二步：向AI咨询，发现“新工具”**
<div style="font-size: 0.9em;">

我们的算法蓝图需要一些我们从未接触过的能力：如何“遍历文件夹”？如何“重命名文件”？

这时，我们不需要去Google搜索，而是直接向我们的“**全能技术顾问**”——AI——提问。

> **探索性Prompt:**
>
> “你好，我想用Python写一个批量重命名文件的脚本。请问我需要用到哪些工具（比如标准库或模块），来实现以下操作：
> 1.  列出某个文件夹里的所有文件名？
> 2.  将一个文件从旧名字重命名为新名字？”

**AI的回答**：它会告诉你，Python的内置`os`模块，就是处理这些操作系统相关任务的“瑞士军刀”。
</div>

<!--
蓝图设计好了，但我们很快会发现一个问题：我们的知识储备里，好像还不知道具体用什么代码来实现“遍历文件夹”和“重命名文件”。
怎么办？去Google或百度上大海捞针吗？不需要！
现在，我们有了一个“全能技术顾问”——AI。我们可以直接向它提问，来探索未知的领域。
我们可以发送这样的“探索性Prompt”：“你好，我想用Python写一个批量重命名文件的脚本。请问我需要用到哪些工具，来实现‘列出所有文件名’和‘重命名文件’这两个操作？”
注意，我们不是让它直接写代码，而是问它“需要用什么工具”。这是一种更高阶的提问技巧。
AI会立刻告诉我们，Python里有一个内置的`os`模块，就是专门处理这类与操作系统打交道的任务的“瑞士军刀”。
-->

---

## **新工具介绍：`os`模块**
<div style="font-size: 0.84em;">

`os`模块提供了我们完成任务所需的所有“工具”：

- **`os.listdir(path)`**
  - **作用**：列出指定`path`文件夹内的所有文件和文件夹名，返回一个**列表**。
- **`os.path.join(path, filename)`**
  - **作用**：智能地将文件夹路径和文件名拼接成一个完整的绝对路径。（比手动拼接更健壮！）
- **`os.path.isfile(full_path)`**
  - **作用**：判断一个给定的完整路径是否是一个**文件**，返回`True`或`False`。
- **`os.rename(source_path, destination_path)`**
  - **作用**：重命名或**移动**一个文件/文件夹。我们将用它来完成重命名。

</div>

<!--
在AI的指引下，我们认识了这个新朋友——`os`模块。我们来看一下它为我们提供了哪些完成任务所必需的“工具”。
首先，`os.listdir()`，它可以列出指定文件夹里的所有项目，并把名字放在一个列表里返回给我们。这完美地对应了我们蓝图里的“遍历”步骤。
其次，`os.path.join()`，它可以智能地把文件夹路径和文件名拼接成一个完整的路径。这比我们自己用加号拼接更专业、更健壮，因为它会自动处理不同操作系统（Windows和macOS）下路径分隔符不同的问题。
然后，`os.path.isfile()`，它可以判断一个路径到底是不是一个文件。这对应了我们蓝图里的“菱形”判断步骤。
最后，`os.rename()`，它可以将一个文件从旧路径重命名为新路径。这就是我们最终要使用的“武器”。
有了这些工具，我们的蓝图就可以从纸面走向现实了。
-->

---

## **第三步(1/3): 从“愿景”到“指令”——提出初始想法**
<div class="columns" style="font-size: 0.9em;">
<div>

我们已经有了清晰的蓝图和工具，但要一次性写出完美的“终极指令”，对新手而言依然是巨大的挑战。

一个更轻松、更符合AI协作精神的工作流是：**与AI一起“迭代”出最终的指令**。

这个过程的第一步，不是追求完美，而是先向AI抛出一个简单的、**“愿景驱动”的初始指令**，告诉它我们大致想做什么。

这就像对一个团队成员说：“嘿，我们大概要做个批量重命名的东西”，而不是直接甩给他一份详细的规格书。

</div>
<div>

> **“愿景驱动”的初始Prompt:**
>
> “你好，我想用Python写一个脚本。
>
> **目标**：批量重命名某个文件夹里的所有文件，为它们统一添加一个前缀字符串。
>
> 你觉得这个任务可行吗？如果让你来做，大致的思路是怎样的？”

</div>
</div>

<!--
好了，我们有了蓝图和工具，但要把这一切转化为一份完美的、滴水不漏的终极指令，对于刚刚接触这些概念的我们来说，挑战还是太大了。
别担心，我们完全没必要自己苦思冥想。一个更轻松、更符合AI协作精神的工作流是：与AI一起，一步步“迭代”出这份最终的指令。
第一步，就是先抛弃“一次写对”的压力，向AI抛出一个非常简单的、“愿景驱动”的初始指令。就像右边这样，只告诉它我们的大目标，然后用开放式的问题，比如“你觉得可行吗？”、“你的思路是怎样的？”，来启动对话。
这就像是和AI进行一次“头脑风暴”的开场。
-->

---

## **第三步(2/3): 引导AI思考“边界情况”**
<div class="columns" style="font-size: 0.9em;">
<div>

在收到初始指令后，AI可能会给你一个简单的实现思路（比如直接使用`os.listdir`和`os.rename`）。

此时，我们的职责不是马上写代码，而是扮演“**压力测试工程师**”的角色，引导AI思考方案中潜在的“**边界情况**”和“**风险**”。

这是从普通使用者到专业开发者的关键一步。

</div>
<div style="font-size: 0.95em;">

> **“挑战边界”的追问Prompt:**
>
> “你的思路听起来不错。但在实际操作中，这个方案有没有什么需要特别注意的‘**边界情况**’或**可能出错**的地方？
>
> 比如：
> 1.  如果文件夹里除了文件，还有**子文件夹**怎么办？
> 2.  如果遇到像`.DS_Store`这样的**隐藏文件**怎么办？
> 3.  如果脚本不小心被**重复执行**了两次，文件名会不会被加上两次前缀？
>
> 请帮我分析这些风险，并提出你的优化建议。”

</div>
</div>

<!--
AI收到我们的初始想法后，可能会给我们一个简单的思路。这时，我们千万不要急着就让它写代码。
我们的职责，是扮演“压力测试工程师”的角色，去挑战它的初步方案。我们可以像右边这样，向AI追问：“你的方案有没有什么需要注意的‘边界情况’或者可能出错的地方？”
我们可以主动举一些例子，比如“有子文件夹怎么办？”、“有隐藏文件怎么办？”、“脚本重复执行了怎么办？”。
这个追问的过程，至关重要。它能迫使AI思考得更周全，从而生成更健壮、更专业的代码。这也是我们作为“开发主管”价值的体现。
-->

---

## **第三步(3/3): 请求AI整合生成“终极指令”**
<div class="columns" style="font-size: 0.9em;">
<div>

经过几轮讨论，我们和AI已经对需求达成了共识，并考虑了各种细节。

现在，我们不必亲自费力去总结，可以把这个任务也交给AI！

我们可以“**升维思考**”，要求AI扮演“**需求分析师**”，将我们刚才的所有讨论，整理成一份高质量的、给“AI程序员”看的“终极指令”。

这是一种强大的“**元能力**”：**利用AI来优化我们与AI自身的沟通**。

</div>
<div style="font-size: 0.9em;">

> **“生成指令”的元Prompt:**
>
> “非常好！我们现在已经把各种情况都考虑清楚了。
>
> 现在，请你**扮演一名专业的‘需求分析师’**，将我们从开始到现在的所有讨论，包括：
> 1.  最初的**核心目标** (加前缀)
> 2.  后来补充的各种**边界情况处理** (跳过子文件夹、跳过隐藏文件、避免重复添加前缀)
> 3.  以及你建议使用的**技术工具** (`os`模块)
>
> 全部整理成一份**清晰、详尽、高质量、步骤化**的开发指令(Prompt)。
>
> 这份指令的目标读者是另一位‘AI程序员’，所以它必须足够精确，没有任何歧义。”

</div>
</div>

<!--
好了，经过几轮讨论，我们和AI已经把所有细节都聊透了。现在是不是要我们自己来总结，写成一份完美的Prompt呢？
不，我们可以把这个工作也交给AI！
我们可以向它发出一个更高级的指令，一个“元指令”。就像右边这样：“非常好！现在请你扮演一名‘需求分析师’，把我们刚才所有的讨论，全部整理成一份清晰、详尽、高质量的开发指令，这份指令是给另一个‘AI程序员’去看的。”
这是一种非常强大的思维：利用AI来优化我们和AI自己的沟通。我们不仅让AI当“程序员”，还让它当“需求分析师”来帮我们写Prompt。
-->

---

## **第四步：审查并执行AI生成的“终极指令”**
<div style="font-size: 0.65em;">

在我们发出了“生成指令”的元Prompt后，AI“需求分析师”就会为我们生成一份融合了我们所有讨论成果的“终极指令”。

这份指令现在成为了我们指导“AI程序员”工作的最终蓝图。我们的任务，是**最后审查一遍**，然后将其发送给AI（甚至可以是同一个AI），让它生成最终脚本。

> **AI生成的终极指令 (审查稿):**
>
> 请为我编写一个Python脚本，名为`batch_renamer.py`，用于给文件批量添加前缀。
>
> 1.  导入`os`模块。
> 2.  定义一个名为 `batch_rename_files` 的函数，它接收 `folder_path` 和 `prefix` 两个字符串作为参数。
> 3.  在函数内部，使用 `os.listdir()` 遍历指定 `folder_path` 下的所有项目。
> 4.  在循环中，构建每个项目的完整路径，并用 `os.path.isfile()` 判断它是否是一个文件。
> 5.  为增加代码健壮性，请只重命名文件，不要对子文件夹进行操作。同时，跳过以`.`开头的隐藏文件。
> 6.  在重命名之前，增加一个判断：如果文件名**已经**以指定`prefix`开头，就跳过这个文件，并打印一条提示信息，避免重复添加前缀。
> 7.  构建新的文件名（`prefix + original_filename`），并基于此构建完整的新文件路径。
> 8.  使用 `os.rename()` 将文件从旧路径重命名为新路径，并打印出重命名的过程，例如：“已重命名: a.txt -> 2025-final-a.txt”。
> 9.  在脚本的**最末尾**，定义两个变量：`TARGET_FOLDER = "./test_folder"` 和 `PREFIX = "2025秋-软件工程-"`。
> 10. 最后，调用 `batch_rename_files(TARGET_FOLDER, PREFIX)` 函数来执行脚本。
</div>

<!--
在我们发出了“生成指令”的元Prompt后，AI“需求分析师”就会为我们生成一份像这样的，融合了我们所有讨论成果的“终极指令”。
这份指令现在成为了我们指导“AI程序员”工作的最终蓝图。
我们作为开发主管的最后一步，就是审查这份由AI助理准备好的指令，看看有没有遗漏。比如，我们之前讨论的“避免重复执行”，它有没有写进去？（看第6点）。
确认无误后，我们就可以把这份完美的指令，发给AI，让它生成最终的脚本代码了。
-->

---

## **动手环节：批量重命名你的“课程文件”**
<div style="font-size: 0.9em;">

在开始动手之前，我们需要建立一个重要的专业认知：一个正规的软件项目，其开发、测试和生产环境是严格分离的。我们编写的任何工具，都必须先在一个安全的“沙盒”环境中进行充分测试，确保它完全符合预期后，才能应用到真实的、重要的数据上。

测试通过后，在我们将工具应用于真实的、海量的课程文件之前，通常还会有一个“**试运行**”阶段。在这个阶段，我们会选择一小部分不那么重要但真实的文件进行操作，并**提前做好数据备份**。这是为了防范那些在沙盒测试中未能发现的、意料之外的BUG，是保障数据安全的最后一道防线。

<div>

![](../../../lectures/images/2025-11-21-13-10-06.png)
</div>

我们今天的实践，主要就是模拟流程图中的“**沙盒测试**”这个过程。
</div>

<!--
在大家开始动手之前，我必须先强调一个极其重要的专业认知。
我们写的这个脚本，是有“破坏力”的，它会真实地修改你电脑上的文件。所以，我们绝不能直接在自己宝贵的教学资料上运行它。
一个专业的开发流程，开发、测试和真实使用（生产）的环境是严格分离的。我们必须先在一个安全的“沙盒”环境里进行充分测试。
测试通过后，在应用于真实文件之前，我们还会进行一次小范围的“试运行”，并且一定要提前做好数据备份！这是保障数据安全的最后一道防线。
我们今天的实践，主要就是模拟这个流程中的“沙盒测试”环节。
-->

---

### **第一步：创建“沙盒环境”与“测试数据”**
<div style="font-size: 0.9em;">

在你的项目根目录下，创建一个名为`test_folder`的文件夹，这就是我们的“沙盒”。然后，在AI助手中，使用以下指令，在沙盒中创建一些用于测试的空白文件：

> 请帮我在`./test_folder/`目录下，创建以下几个空白文件：`课程大纲.docx`, `第1课讲义.pptx`, `学生名单.xlsx`。

### **第二步：执行“重命名脚本”**
1.  向AI发送我们上一页的“**终极指令**”，让它生成`batch_renamer.py`脚本。
2.  **审查代码**：花一分钟时间，对照你的指令，检查AI生成的代码逻辑是否完全符合你的设计。
3.  在VS Code的终端中，运行这个脚本：`python batch_renamer.py`

### **第三步：验证“测试结果”**
- 查看你的`test_folder`“沙盒”。
- 所有测试文件的名字是否都成功地被加上了你设定的前缀？（例如：`2025秋-软件工程-课程大纲.docx`）

</div>

<!--
好了，现在我们正式开始动手！
第一步，创建我们的“沙盒环境”。请大家在你的项目根目录下，手动创建一个名为`test_folder`的文件夹。然后，我们可以指挥AI，帮我们在这个沙盒里创建一些用于测试的空白文件。你可以直接复制这里的指令发给AI。
第二步，执行脚本。向AI发送我们上一页那份详细的“终极指令”，让它为你生成`batch_renamer.py`这个脚本。拿到代码后，花一分钟时间，扮演一次“代码审查员”，对照你的指令，看看AI的实现是不是完全符合你的设计。确认无误后，在VS Code的终端里，输入`python batch_renamer.py`来运行它。
第三步，验证结果。回到你的文件浏览器，查看`test_folder`文件夹。里面的文件名是不是都像我们预期的那样，被成功地加上了前缀？
如果一切顺利，恭喜你，你已经成功地指挥AI，为你打造了一个实用的自动化工具！
-->

---

## **模块三总结：你已是合格的“AI开发主管”**

<div class="columns ratio-6-4">
<div style="font-size: 0.8em;">

**祝贺你，完成了模块三的终极试炼！**

让我们回顾一下在本模块，你作为“AI开发主管”所掌握的三大核心领导力：

- **封装与授权 (函数)**
  - 你学会了将复杂任务分解，并“授权”给一个个独立的函数去执行。
- **品控与纠错 (调试)**
  - 你学会了管理AI的“失误”，通过分析报告和清晰指令，引导其修复问题。
- **评审与决策 (审查)**
  - 你学会了评估AI的不同方案，并基于权衡做出最终的架构决策。

你已经不再是AI的简单使用者，而是能**驾驭AI**，主导项目从设计、实现、到质量把控全流程的**领导者**。

</div>
<div class="align-middle-center">

![一个自信的领导者，身后是代表函数、调试、审查的图标，他/她正在指挥一个AI团队 width:400px](../../../lectures/images/2025-11-21-01-03-59.png)

</div>
</div>

<!--
（在学员完成实践后）
祝贺大家，成功完成了模块三的终极试炼！
让我们一起回顾一下，在这个模块，你作为“AI开发主管”，掌握了哪些核心的领导力。
通过学习函数，你学会了“封装与授权”，将任务分解。
通过学习调试，你学会了“品控与纠错”，管理AI的失误。
通过学习代码审查，你学会了“评审与决策”，在不同方案中做权衡。
可以说，你已经不再是AI的一个简单使用者，而是能真正驾驭AI，主导项目从设计、实现到质量把控全流程的领导者。为你自己的成长喝彩！
-->

---

## **课程成长路径：从“魔法学徒”到“作坊工匠”**

<div class="columns align-middle">
<div>

![width:250px](../../../lectures/images/2025-11-03-12-09-12.png)

</div>

<div>

| 阶段 | 目标 | 对应模块 |
| :--- | :--- | :--- |
| **魔法学徒** | 掌握编程基础，学习封装复用 | 模块 1-3 ✅ |
| **作坊工匠** | 处理真实数据，构建交互工具 | 模块 4-6 |
| **初级建筑师** | 构建综合项目，转化教学设计 | 模块 7-8 |

**我们已经成功完成了“魔法学徒”阶段的全部修行！**
你不仅掌握了编程的基础规则，更学会了封装与复用代码的核心思想。

</div>
</div>

<!--
让我们再次回到我们的课程成长路径图。
随着模块三的结束，我非常荣幸地向大家宣布：我们已经成功完成了“魔法学徒”阶段的全部修行！
你不仅掌握了编程的变量、条件、循环这些基础规则，更重要的是，学会了封装与复用代码的核心思想。
接下来，我们将进入一个全新的阶段——“作坊工匠”。我们将开始学习如何处理真实的、外部的数据，并构建有交互界面的工具。
-->

---

## **下一步预告：模块四 - AI数据分析师(上)**

<div class="columns ratio-6-4">
<div style="font-size: 0.82em;">

到目前为止，我们所有的“数据”都来自于我们自己在代码中“**硬编码**”的`world`字典，或是简单的文件名。

但现实世界中，更有价值的数据，往往存在于**外部文件**中，例如：
- 一份包含全班学生成绩的 **Excel 表格**。
- 一份从网站下载的、包含数千行数据的 **CSV 文件**。

**我们如何指挥AI：**
- 读取并理解这些复杂的表格数据？
- 从海量数据中，筛选出我们关心的特定行和列？
- 对数据进行清洗、统计，并发现其中的规律？

在下一个模块，我们将开启全新的篇章，学习如何成为一名“**AI数据分析师**”，并认识一个数据科学领域最强大的工具——**Pandas**！

</div>
<div class="align-middle-center">

![一个数据分析师与AI机器人一起，看着屏幕上由Excel表格转换成的酷炫图表 width:400px](../../../lectures/images/2025-11-21-01-05-17.png)

</div>
</div>

<!--
在结束今天的课程前，让我们展望一下下一段更精彩的旅程。
到目前为止，我们处理的数据，要么是我们自己在代码里写的字典，要么是简单的文件名。但现实世界中，更有价值的数据，往往存在于外部的Excel表格或CSV文件中。比如我们的学生成绩单、科研数据等等。
我们如何指挥AI去读取和理解这些复杂的表格数据？如何从海量数据中筛选出我们想要的信息？又如何对数据进行清洗、统计，并发现其中的规律？
在下一个模块，我们将开启一个全新的篇章，学习如何成为一名“AI数据分析师”，并认识一个在数据科学领域最强大的工具——Pandas库！
请大家保持期待，我们模块四见！
-->

---

# 课后练习

<style scoped>
section {
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  text-align: center;
}

h1 {
  font-size: 60px;
  margin-bottom: 20px;
}

p {
  font-size: 24px;
  color: #555;
  line-height: 1.5;
}
</style>

<p>

*小提示：你已经是合格的“AI开发主管”了！<br>尝试将下面的需求，像设计蓝图一样拆解成清晰的步骤，然后指挥你的AI助手来完成开发和调试。*
</p>

---

## ****课后练习：让你的“文件助手”更智能 (基础)****

我们已经完成了一个实用的批量重命名工具。但是，一个“智能”的助手，应该更懂得“偷懒”和“猜测”用户的意图。

请向你的AI助手提出新的需求，对`batch_renamer.py`进行迭代升级。

#### **挑战一：更灵活的路径处理**
> *“如果用户在运行时，不提供`folder_path`参数，我们的脚本应该默认处理运行脚本时所在的文件夹。请为`batch_rename_files`函数增加这个默认行为。”*

<div class="insight" style="font-size: 0.9em; margin-top: 20px;">

**思考**：这需要修改函数的哪个部分？`os.getcwd()` 也许能派上用场。

</div>

---

## ****课后练习：让你的“文件助手”更智能 (进阶)****

#### **挑战二：更友好的前缀参数**
> *“除了现有的`prefix`参数，我希望函数能支持更友好的`semester_name`（学期名称）和`course_name`（课程名称）参数。当这些参数被提供时，它们会自动组合成`prefix`，例如 `2025秋-软件工程-`。”*

<div class="insight" style="font-size: 0.9em; margin-top: 20px;">

**思考**：函数的定义（参数列表）需要做什么改变？函数内部如何根据不同的输入参数来决定最终的`prefix`？

</div>

---

## ****课后练习：让你的“文件助手”更智能 (挑战)****

<div style="font-size: 0.95em;">

#### **挑战三：智能的“学期名”生成**
> *“如果用户没有提供`semester_name`，我希望脚本能根据当前的系统日期，自动生成学期名称。规则如下：”*
> - *如果当前月份在9月到1月之间，学期为 `{当年}秋` (例如 2025年11月 -> `2025秋`)。*
> - *如果当前月份在3月到6月之间，学期为 `{上一年}春` (例如 2025年4月 -> `2024春`)。*
> - *如果当前月份在7月到8月之间，学期为 `{当年}夏` (例如 2025年7月 -> `2025夏`)。*
> - *如果当前是2月，则让用户从两个学期中选择一个（例如，提示用户输入‘1’代表‘2024秋’，输入‘2’代表‘2025春’）。*
</div>

<div class="insight" style="font-size: 0.9em; margin-top: 20px;">

**思考**：你需要什么新“工具”来获取当前日期？（提示：向AI询问`datetime`模块）。这个逻辑用`if-elif-else`结构会非常清晰。对于2月份的选择，你该如何实现用户交互？（提示：`input()`函数）

</div>

---

## ****课后练习：让你的“文件助手”更智能 (终极挑战)****

#### **挑战四：智能的“课程名”猜测**
> *“如果用户没有提供`prefix`和`course_name`，我希望脚本能变得更‘聪明’一点。它应该分析当前的文件夹路径，并从中**模糊匹配**出可能的课程名称。例如，如果脚本在`/Users/teacher/Documents/MyCourses/Software_Engineering_2025/`路径下运行，它应该能猜出课程名是‘Software Engineering’。”*

<div class="insight" style="font-size: 0.9em; margin-top: 20px;">

**思考**：这是一个开放性挑战！你该如何向AI描述这个“模糊匹配”的需求？是基于文件夹名称的关键词？还是需要一个预设的课程列表？尝试设计你的方案并指挥AI实现。

</div>