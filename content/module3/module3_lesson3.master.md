---
marp: true
theme: default
paginate: true
size: 16:9
---

<style>
/* --- 布局辅助样式 --- */
.columns {
  display: grid;
  grid-template-columns: repeat(2, minmax(0, 1fr));
  gap: 1rem;
}
.columns pre code {
  white-space: pre-wrap !important;
  overflow-wrap: break-word !important;
}
/* --- 列表缩进样式修正 --- */
ul, ol {
  padding-inline-start: 25px; /* 减小列表的左侧缩进 */
}
.columns.ratio-4-6 { grid-template-columns: 4fr 6fr; }
.columns.ratio-6-4 { grid-template-columns: 6fr 4fr; }
.columns.ratio-3-7 { grid-template-columns: 3fr 7fr; }
.columns.ratio-7-3 { grid-template-columns: 7fr 3fr; }
.align-top    { display: flex; align-items: flex-start; }
.align-middle { display: flex; align-items: center; }
.align-bottom { display: flex; align-items: flex-end; }
.align-left   { display: flex; justify-content: flex-start; }
.align-center { display: flex; justify-content: center; }
.align-right  { display: flex; justify-content: flex-end; }
.align-top-left     { display: flex; justify-content: flex-start; align-items: flex-start; }
.align-top-center   { display: flex; justify-content: center;  align-items: flex-start; }
.align-top-right    { display: flex; justify-content: flex-end;   align-items: flex-start; }
.align-middle-left  { display: flex; justify-content: flex-start; align-items: center; }
.align-middle-center{ display: flex; justify-content: center;  align-items: center; }
.align-middle-right { display: flex; justify-content: flex-end;   align-items: center; }
.align-bottom-left  { display: flex; justify-content: flex-start; align-items: flex-end; }
.align-bottom-center{ display: flex; justify-content: center;  align-items: flex-end; }
.align-bottom-right { display: flex; justify-content: flex-end;   align-items: flex-end; }
.tip {
  background-color: #f0f8ff;
  border-left: 5px solid #1e90ff;
  padding: 15px 15px 0.1px; 
}
.insight {
  background-color: #eefcff; 
  border-left: 5px solid #17a2b8; 
  padding: 15px 15px 0.1px; 
}
.key-point {
  background-color: #fffbe6; 
  border-left: 5px solid #ffc107; 
  padding: 15px 15px 0.1px; 
}
.tip p, .tip li,
.insight p, .insight li,
.key-point p, .key-point li {
  font-size: inherit !important;
}
.styled-div p, 
.styled-div li, 
.styled-div ol, 
.styled-div ul, 
.styled-div blockquote {
  font-size: inherit !important;
}
</style>

![bg blur:3px brightness:60%](image/2025-11-21-01-07-42.png)

<style scoped>
h1{
  color: #F5F5F5; /* 设置文字颜色为白色 */
  text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.8); /* 添加一个柔和的深色阴影 */
}
h2 {
  color: #E0E0E0; /* 设置文字颜色为白色 */
  text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.8); /* 添加一个柔和的深色阴影 */
}
.course-title {
  position: absolute;
  top: 60px;
  left: 80px;
  background-color: rgba(0, 0, 0, 0.4);
  color: #fff;
  padding: 8px 15px;
  border-radius: 5px;
  font-size: 22px;
  font-weight: bold;
  letter-spacing: 1px;
  border-left: 5px solid #4CAF50; /* 用一条强调色作为装饰 */
}
</style>

<div class="course-title">AI赋能软件开发</div>

# 模块三: 代码复用与人机协作
## 第11节课: AI代码审查会——从“能跑”到“优雅”

<div style="position: absolute; bottom: 40px; left: 80px; color: rgba(255, 255, 255, 0.8); font-size: 18px; font-family: sans-serif;">
南昌大学计算机系 黎鹰
</div>

<!--
- **类型**: 逐字稿
- **内容**: |
  各位老师好，欢迎来到我们模块三的第三节课。
  在上一节课，我们扮演了“项目经理”，学会了如何修复让程序崩溃的Bug。今天，我们要挑战一个更高级别的话题。
  我们将一起召开一场“AI代码审查会”，学习如何将我们的代码，从仅仅“能跑”的水平，提升到“优雅”的境界。
-->

<!--
- **类型**: 教学设计
- **内容**: |
  ### 教学时间: 1分钟
  ### 开场：从“能跑”到“优雅”
  本页作为课程开场，核心目标是点明本节课的主题——代码审查(Code Review)，并通过“从‘能跑’到‘优雅’”这个吸引人的副标题，帮助学员建立对“代码质量”这一更高层次追求的初步认知。

  **核心要点**:
  1. **点明主题**: 清晰地揭示本节课的主题是“AI代码审查会”。
  2. **提升认知**: 引入“能跑”与“优雅”的对比，将学员的关注点从功能的有无，提升到质量的高低。
  3. **建立期待**: 预示着学员将要学习一项更高级的、关于“品味”的技能。
-->

<!--
- **类型**: 解释
- **内容**: |
  ### 代码审查 (Code Review)
  **代码审查**是软件开发中的一个核心实践，指的是让其他开发者（或自己，或AI）系统性地检查一段源代码。

  **代码审查的主要目的**:
  1.  **提升代码质量**: 发现并改进代码中潜在的逻辑问题、性能瓶颈、不符合规范的写法等。
  2.  **发现潜在缺陷**: 审查者作为“第二双眼睛”，往往能发现原作者忽略的Bug。
  3.  **知识共享**: 团队成员通过阅读彼此的代码，可以学习新的技巧、了解系统的不同部分，促进团队整体水平的提升。
  4.  **保持风格一致**: 确保整个项目的代码风格（如命名、格式化等）保持统一，提高代码库的整体可读性。

  在AI辅助开发的模式下，我们可以利用AI作为我们永不疲倦的、知识渊博的“代码审查伙伴”。
-->

---

## **回顾：当代码“能跑”，但我们仍不满意**

<div class="columns ratio-6-4">
<div style="font-size: 0.9em;">

在之前的课程中，我们已经取得了巨大的成就：
- 我们构建了一个能运行的游戏引擎。
- 我们学会了用函数封装逻辑。
- 我们甚至学会了如何指挥AI修复让程序崩溃的Bug。

但是，一个新的、更深层次的问题浮出水面：

**如果一段代码能够正常运行，没有报错，但它写得非常糟糕——难以阅读、难以修改——我们该怎么办？**

仅仅满足于“能跑”，会让我们的项目在未来变得举步维艰。作为追求卓越的“架构师”，我们必须开始追求更高层次的目标：**代码质量**。

</div>
<div class="align-middle-center">

![一个混乱但能正常运转的作坊，和一个整洁有序的现代化工厂，形成对比 width:400px](image/2025-11-21-01-09-09.png)

</div>
</div>

<!--
- **类型**: 逐字稿
- **内容**: |
  在上一节课的最后，我们留下了一个更深层次的思考题：当我们的代码能跑、不出错，但这真的就足够了吗？

  我们回顾一下游戏代码，会发现里面充斥着像 `'guangchang'`、`'exits'` 这样的字符串。如果某天不小心拼错一个，就可能引入一个很难发现的Bug。这种代码，我们称之为‘脆弱的’、‘易腐烂的’。

  仅仅满足于‘能跑’，就像运营一个能出货但混乱不堪的手工作坊。任何一个环节出错，都可能导致整个生产线停摆。作为追求卓越的开发者，我们今天的任务，就是把这个‘作坊’升级为‘现代化工厂’，引入‘代码质量’的标准和规范。
-->

<!--
- **类型**: 教学设计
- **内容**: |
  ### 教学时间: 2分钟
  ### 回顾痛点：不满足于“能跑”
  本页的核心目标是承上启下，通过重现上一节课结尾留下的“代码能工作，但质量不高”这一更深层次的痛点，并借助“混乱作坊 vs 现代化工厂”的比喻，来激发学员追求“代码质量”的内在动机。

  **核心要点**:
  1. **连接过去**: 肯定学员已有的成就（能构建、能修复），然后引出新的、更高级的问题。
  2. **痛点可视化**: 用“作坊 vs 工厂”的比喻，让“代码质量”这一抽象概念的优劣变得具体可感。
  3. **建立动机**: 明确提出“代码质量”是“追求卓越的架构师”必须关注的目标，提升学员的学习动力。
-->

<!--
- **类型**: 解释
- **内容**: |
  ### 代码异味 (Code Smell)

  软件工程中，把那些预示着深层问题的代码特征，称为“**代码异味 (Code Smell)**”。它不是Bug（程序能正常运行），但它暗示着代码的设计可能存在缺陷，未来可能导致问题。

  我们当前代码中就存在典型的代码异味：
  - **神秘字符串 (Magic Strings)**: 在代码中多次出现的、没有解释的字符串字面量（如 `'exits'`, `'description'`, `'south'`）。如果需要修改（例如，将 `'exits'` 改为 `'outlets'`），就必须找到并修改所有出现的地方，极易遗漏。
  - **数据与逻辑耦合**: 我们的游戏世界（数据）和游戏引擎（处理逻辑的代码）混在一起。理想情况下，定义世界的“地图”应该和“如何移动”的逻辑分离开。

  本节课的“代码审查”，其核心目的之一，就是学会识别并清除这些“代码异味”，从源头上提升代码的健康度。
-->

---

## **本节课目标：培养你的“代码品味”**

本节课，我们将扮演“**首席技术官 (CTO)**”或“**架构评审委员会**”的角色，学习一项在专业软件开发中至关重要的活动：**代码审查 (Code Review)**。

我们将利用AI，召开一场别开生面的“**AI代码审查会**”。

### **你的新能力：**
1.  **评估代码质量**
    - 学会从“可读性”、“简洁性”等维度，评判一段代码的“好”与“坏”。
2.  **激发AI的“创造力”**
    - 学会如何引导AI为同一个问题提供多种不同的解决方案。
3.  **做出“架构决策”**
    - 学会如何向AI提问，让它分析不同方案的优劣，并基于分析做出最适合你的项目的技术选型。

**最终，你将拥有良好的“代码品味”，能指挥AI写出不仅“能跑”，而且“优雅”的代码。**

<!--
- **类型**: 逐字稿
- **内容**: |
  为了追求更高的代码质量，今天，我们将再次进行角色升级。我们将扮演“首席技术官(CTO)”或“架构评审委员会”的角色，来学习一项专业开发中的核心活动——代码审查。
  我们将利用AI，召开一场别开生面的“AI代码审查会”。
  通过这节课，你将获得三项高阶能力：
  第一，评估代码质量。你将学会如何评判一段代码的好与坏。
  第二，激发AI的创造力。你将学会如何引导AI为你提供多种不同的解决方案，而不是只满足于第一个答案。
  第三，做出架构决策。你将学会如何要求AI分析这些方案的优劣，并最终由你来拍板，决定采用哪一个。
  最终，你将拥有程序员非常看重的一种素养——“代码品味”，能指挥AI写出不仅“能跑”，而且“优雅”的代码。
-->

<!--
- **类型**: 教学设计
- **内容**: |
  ### 教学时间: 2分钟
  ### 设定目标：培养你的“代码品味”
  本页旨在明确本节课的核心学习目标与新的角色定位。通过将“代码审查”这一活动，包装成“培养代码品味”的高阶能力，并引入“CTO”、“架构评审委员会”等新角色，清晰地定义学员将获得的“评估质量”、“激发AI”、“做出决策”三项核心能力。

  **核心要点**:
  1. **能力升级**: 将“代码审查”重新定义为一项关于“品味”的、更高阶的审美和决策能力。
  2. **角色重塑**: 提出“CTO”或“架构评审委员会”的新角色，进一步提升学员的价值感和主人翁意识。
  3. **明确产出**: 将学习目标分解为“评估”、“激发”、“决策”三个具体、可操作的能力点。
-->

<!--
- **类型**: 解释
- **内容**: |
  ### 代码质量的维度
  “代码质量”不是一个单一的指标，而是由多个维度构成的综合评价。对于初学者而言，最重要的几个维度是：
  - **可读性 (Readability)**: 代码是否清晰、易于理解？变量和函数命名是否恰当？
  - **简洁性 (Conciseness)**: 代码是否言简意赅？有没有不必要的重复和冗余？
  - **可维护性 (Maintainability)**: 当需求变更时，修改代码是否容易？是否会牵一发而动全身？
  - **健壮性 (Robustness)**: 代码是否考虑了各种边界情况和异常输入？

  本节课的“代码审查”，将主要围绕“可读性”和“简洁性”这两个最直观、也最重要的维度展开。
-->

---

## **什么是“好代码”？—— 可读性是第一原则**

<div class="columns ratio-6-4">
<div style="font-size: 0.9em;">

对于代码质量，有许多评判标准（效率、健壮性、安全性...），但对于我们和AI协作的场景，最重要的、压倒一切的原则是：

**可读性 (Readability)**

一段“好代码”，首先应该像一篇“**好文章**”。一个不熟悉项目的开发者（或者几个月后的你自己），应该能轻松地读懂它的意图。

> “任何一个傻瓜都能写出计算机可以理解的代码。唯有优秀的程序员才能写出人类可以理解的代码。”
> — Martin Fowler

在AI时代，这句话变得尤为重要。因为AI负责“写”，而我们人类的核心职责，变成了“**读**”和“**审**”。

</div>
<div class="align-middle-center">

![一段像诗一样排版优美的代码，和一段混乱不堪的代码，形成对比 width:400px](image/2025-11-21-01-12-33.png)

</div>
</div>

<!--
- **类型**: 逐字稿
- **内容**: |
  那么，到底什么是“好代码”呢？
  评判标准有很多，比如运行效率高不高、安不安全等等。但对于我们和AI协作的场景，对于我们初学者来说，最重要的、压倒一切的原则，就是“可读性”。
  一段好的代码，首先应该像一篇好文章。一个不熟悉这个项目的人，比如你的同事，或者几个月后已经忘掉细节的你自己，应该能很轻松地读懂这段代码想干什么。
  计算机领域的思想家马丁·福勒有句名言：“任何一个傻瓜都能写出计算机可以理解的代码。唯有优秀的程序员才能写出人类可以理解的代码。”
  在AI时代，这句话的意义被放大了。因为AI非常擅长写计算机能理解的代码，而我们人类的核心职责，越来越多地转向了“阅读”和“审查”AI写的代码。如果我们读不懂，我们就无法驾驭它。
-->

<!--
- **类型**: 教学设计
- **内容**: |
  ### 教学时间: 2分钟
  ### 定义标准：可读性是第一原则
  本页旨在为“代码质量”这一模糊概念，建立一个清晰、明确、且在当前阶段最重要的核心评判标准——可读性。

  **核心要点**:
  1. **确立核心标准**: 在众多代码质量标准中，明确“可读性”是第一原则，避免学员陷入混乱。
  2. **建立比喻**: 将“好代码”比作“好文章”，这是一个非技术人员也能立刻理解的类比。
  3. **引用权威**: 引用Martin Fowler的名言，增加观点的说服力。
  4. **连接课程主旨**: 强调在AI时代，人类的核心职责是“读”和“审”，从而再次凸显可读性的核心地位。
-->

<!--
- **类型**: 解释
- **内容**: |
  ### 代码即文档
  “好代码是自解释的 (Good code is self-documenting)”是编程界的一句谚语。它强调代码本身就应该是最好的文档。实现这一点，主要依靠：
  - **清晰的命名**: 变量名、函数名应该准确地反映其用途。例如，`batch_rename_files` 就比 `brf` 或 `process` 要好得多。
  - **简洁的逻辑**: 函数应该短小且只做一件事。复杂的逻辑应该被拆分为多个更简单的函数。
  - **一致的风格**: 遵循统一的格式化和代码风格，使得阅读体验更流畅。
  - **必要的注释**: 只在代码本身无法清晰表达“为什么”这么做时，才添加注释。避免解释“是什么”的无用注释。

  在与AI协作时，我们不仅要审查AI生成的代码是否符合这些可读性标准，更要在我们的Prompt中，就要求AI使用清晰的命名和结构。
-->

---

## **AI的“陷阱”：它倾向于给你“最快”而非“最好”的答案**

<div class="columns ratio-6-4">
<div style="font-size: 0.9em;">

  要进行代码审查，我们首先要理解AI的一个“陷阱”，或者说它的工作倾向。

  当我们向AI提出一个需求时，它并不会像人类专家那样，深思熟虑地比较所有可能的方案，然后选出最好的一个。相反，它会基于其庞大的数据和概率模型，快速地沿着一条它认为**概率最高**的路径，生成一个最“**通顺**”或最“**常见**”的答案。

  这就像一个急于完成任务的新手程序员，他给你的代码能用，但未必是经过深思熟虑的最佳实践。

  如果我们满足于AI给出的第一个答案，我们可能就错过了学习更优雅、更地道的编程范式的机会。

  **作为“首席技术官”，我们的职责就是挑战AI，激发它的“潜力”，让它交出更多、更好的方案供我们评审。**
</div>
<div class="align-middle-center">

![一个AI大脑中，有多条路径可以到达终点，但它只选择了一条最直接的路径 width:400px](image/2025-11-21-01-14-21.png)

</div>
</div>

<!--
- **类型**: 逐字稿
- **内容**: |
  要进行代码审查，我们首先要理解AI的一个“陷阱”，或者说它的工作倾向。

  当我们向AI提出一个需求时，它并不会像一个人类专家那样，深思熟虑地比较所有可能的方案，然后选出最好的那一个。相反，它会基于其庞大的数据和概率模型，快速地沿着一条它认为概率最高的路径，生成一个最“通顺”或最“常见”的答案。

  这就像一个急于完成任务的新手程序员，他给你的代码能用，但未必是最好的。

  如果我们满足于AI给出的第一个答案，我们就可能错过了学习更优雅、更地道的编程写法的机会。

  所以，作为“首席技术官”，我们的职责，就是不能满足于第一个答案。我们要主动去挑战AI，激发它的“潜力”，让它把压箱底的、更好的方案也交出来，供我们评审。
-->

<!--
- **类型**: 教学设计
- **内容**: |
  ### 教学时间: 2分钟
  ### 揭示问题：AI的“捷径”陷阱
  本页旨在揭示AI工作方式的固有局限性，即它倾向于提供“最快”而非“最好”的答案，从而为“挑战AI”这一核心操作建立理论上的必要性。

  **核心要点**:
  1. **揭示局限**: 明确指出AI为了效率，通常只会给出最直接的方案，可能会隐藏更优的解法。
  2. **生动比喻**: 将AI比作“急于完成任务的新手程序员”，生动地解释了为什么AI的第一个答案未必是最好的，易于学员理解。
  3. **转变角色**: 引导学员从“被动接受者”转变为“主动挑战者”，激发他们探索更优方案的欲望。
-->

<!--
- **类型**: 解释
- **内容**: |
  ### LLM的工作原理与Prompt工程
  大型语言模型（LLM）的这个“陷阱”，根植于它的工作原理。LLM本质上是一个“**序列预测模型**”，它的核心任务是在给定一串文本（你的Prompt）后，预测下一个最有可能出现的词（Token）。

  - 当你给出一个简单需求时，最常见的、在训练数据中出现次数最多的代码片段，自然就是“最有可能”的序列，因此AI会优先生成它。
  - 这种机制使得AI在没有额外约束的情况下，倾向于生成“**平庸**”但“**安全**”的代码。

  “**Prompt工程**”的精髓之一，就是通过在Prompt中添加更具体、更高级的**约束**和**引导**（例如，“请使用函数式编程风格”、“请让代码更Pythonic”、“请考虑性能”），来改变词语的概率分布，从而引导AI跳出“最常见”的路径，去探索那些虽然不那么常见，但可能更优的解决方案空间。
-->

---

## **代码审查初体验：审视我们自己的游戏**

<style scoped>
pre code {
  font-size: 40px !important; /* 尝试设置一个更大的值 */
  line-height: 1.5 !important; /* 压缩行间距，防止被挤出屏幕 */
}
</style>

<div class="columns ratio-6-4">
<div style="font-size: 0.8em;">

现在，让我们以“首席技术官”的身份，审查项目代码 `mud_game_v4.py`。

请大家打开代码，思考两个问题：

1.  **数据是否一致？**
    - 请看 `world` 字典中 `'guangchang'` 的 `'description'`（描述）和 `'exits'`（出口）两个键。它们之间是否存在潜在的矛盾？

2.  **功能是否完整？**
    - 运行游戏，停留在“扬州广场”。
    - 输入 `/look` 指令后，程序输出的描述信息，和我们作为玩家的**预期**是否一致？它真的把出口方向告诉我们了吗？

</div>
<div class="styled-div" style="font-size: 0.85em;">

**审查对象 1：`'guangchang'` 的定义**
```python
'guangchang': {
    'name': '扬州广场',
    'description': '...往南是一家客栈，往北是一家茶馆，往西是铁匠铺，往东是药铺。',
    'exits': {'south': 'kezhan', 
              'north': 'chaguan', 
              'west': 'tjiangpu', 
              'east': 'market'},
    'items': ['布告栏']
},
```

**审查对象 2：`handle_look` 函数**
```python
def handle_look(current_room_data, ...):
    print(current_room_data['name'])
    print(current_room_data['description'])
    if current_room_data['items']:
        print("你看到了: " + ", ".join(current_room_data['items']))
    # ... (显示NPC的代码)
```

</div>
</div>

<!--
- **类型**: 样式替换
- **版本**: [handout, teacher]
- **查找**: |
    <div class="styled-div" style="font-size: 0.85em;">
- **替换**: |
    <div class="styled-div" style="font-size: 0.6em;">
-->

<!--
- **类型**: 逐字稿
- **内容**: |
  在我们学习抽象的审查流程之前，先来一次实战演练。让我们戴上“首席技术官”的帽子，一起审查这份代码。
  
  请大家打开第11课的起始代码，我们来看两个地方。
  
  第一个问题，数据一致性。请看`guangchang`这个地点的定义。它的`description`描述里，写着“往东是药铺”，但下面的`exits`出口数据里，`'east'`指向的却是`'market'`（一个不存在的市场）。这就是一个典型的“代码异味”：**数据冗余导致不一致**。同一份信息（出口方向）被存储在了两个地方，一旦修改不同步，就会产生矛盾。
  
  第二个问题，功能完整性。大家运行一下游戏，然后输入`/look`。我们期望能看到出口信息，但程序只打印了描述和物品，**根本没有告诉我们出口在哪里**！`handle_look`函数压根就没实现这个功能。
  
  很好，通过这次审查，我们发现了一个明确的、需要被实现的功能。这就是我们接下来“AI代码审查会”的议题。
-->

<!--
- **类型**: 教学设计
- **内容**: |
  ### 教学时间: 3分钟
  ### 审查初体验：在自己的代码中发现问题
  本页的核心目标，是将在前几页建立的、抽象的“代码审查”概念，立刻落地为一次具体的、与学员切身相关的实践。通过引导学员审查自己的项目代码，并主动发现其中存在的问题（数据冗余、功能缺失），来为后续的“代码审查会”环节，建立一个真实、具体、有代入感的“议题”。

  **核心要点**:
  1.  **从理论到实践**: 将抽象的“审查”概念，转化为一次对学员自己代码的真实操作，加强参与感。
  2.  **引导式发现**: 不直接告知问题，而是通过并列展示代码和提出引导性问题，让学员自己“发现”代码中的不一致和功能缺失，获得“Aha!”时刻。
  3.  **建立动机**: 找到自己代码中的“瑕疵”，会比任何外部例子更能激发学员“修复它、完善它”的内在动机，为后续课程建立强烈的学习需求。
-->

<!--
- **类型**: 解释
- **内容**: |
  ### 单一来源原则 (Single Source of Truth)
  
  我们发现的第一个问题，违背了软件设计中一条非常重要的原则——“**单一来源原则 (SSoT)**”。
  
  这个原则主张，系统中的每一条信息，都应该有且仅有一个权威的、可信的来源。在我们的例子中，“出口信息”的唯一权威来源应该是`exits`字典。而`description`中的描述，应该是在运行时根据`exits`字典动态生成的，而不应该被硬编码写死。
  
  硬编码（Hard-coding）数据会导致：
  - **维护困难**：当出口变化时，你需要同时修改`exits`字典和`description`字符串。
  - **数据不一致**：像我们看到的那样，一旦忘记同步修改，就会立刻产生Bug。
  
  代码审查的一个重要任务，就是找出这种违反SSoT原则的设计，并将其重构。
-->

---

## **人机协作新流程：“AI代码审查会”三步法**

为了系统性地提升AI产出代码的质量，我们可以遵循一套简单的“代码审查”流程。

<div class="columns" style="font-size: 0.8em; gap: 2rem;">
<div style="text-align: center;">
<p style="font-size: 3em; margin-bottom: 0;">1️⃣</p>
<h3 style="margin-top: 0.5rem;">获取初始方案</h3>
<p>首先，像平常一样向AI提出你的功能需求，让它生成一个可以工作的“初稿”。</p>
</div>
<div style="text-align: center;">
<p style="font-size: 3em; margin-bottom: 0;">2️⃣</p>
<h3 style="margin-top: 0.5rem;">挑战替代方案</h3>
<p>在AI完成初稿后，向它发起“挑战”，要求它提供不同的实现方式。</p>
</div>
</div>
<div style="text-align: center;">
<p style="font-size: 3em; margin-bottom: 0;">3️⃣</p>
<h3 style="margin-top: 0.5rem;">要求对比分析</h3>
<p>让AI扮演“专家”的角色，为你分析和对比不同方案的优缺点。</p>
</div>


这个流程，将你从一个被动的“需求方”，转变为一个主动的“**评审者**”和“**决策者**”。

<!--
- **类型**: 逐字稿
- **内容**: |
  那么，具体该怎么做呢？我们可以把这个过程，规范成一个简单的“AI代码审查会”三步法。
  第一步，获取初始方案。就像平常一样，先让AI给你一个能跑的“初稿”。
  第二步，挑战替代方案。拿到初稿后，不要满足，而是向AI发起挑战，要求它提供不同的、更好的实现方式。
  第三步，要求对比分析。让AI扮演“专家”，为你详细分析和对比不同方案的优缺点。
  通过这个简单的三步流程，你就从一个被动的“需求方”，转变为一个主动的“评审者”和“决策者”。
-->

<!--
- **类型**: 教学设计
- **内容**: |
  ### 教学时间: 2分钟
  ### 建立流程：“AI代码审查会”三步法
  本页旨在建立一套清晰、可执行的“AI代码审查”工作流，将一个看似复杂的高阶活动，分解为普通学员也能轻松掌握的标准化流程。

  **核心要点**:
  1. **流程标准化**: 将代码审查活动分解为“获取初稿 -> 挑战方案 -> 要求分析”三个简单、明确的步骤。
  2. **可视化呈现**: 使用数字图标和居中布局，让三个步骤一目了然，易于记忆。
  3. **明确角色转变**: 在流程结尾，再次点明这个流程带来的角色转变（从“需求方”到“评审者”和“决策者”），强化其价值。
-->

<!--
- **类型**: 解释
- **内容**: |
  ### 决策制定的框架
  这个“三步法”本质上是一个简化的决策制定框架，在许多领域都有应用：
  1.  **建立基线 (Establish a Baseline)**: 获取一个可行的初始方案，作为比较和评估的基准。
  2.  **探索备选 (Explore Alternatives)**: 积极寻找多种可能的解决方案，避免“隧道视野”或过早地锁定在第一个想到的方案上。
  3.  **权衡分析 (Trade-off Analysis)**: 基于一套明确的标准（如成本、风险、收益、可读性、性能等），系统性地评估各个备选方案的利弊。
  4.  **做出决策 (Make a Decision)**: 基于分析结果，选择最符合当前目标的方案。

  将这个框架应用于与AI的互动中，能让你从一个简单的“问答者”，转变为一个能利用AI进行复杂问题分析和决策的“思考者”。
-->

---

## **审查会开题：实现“出口显示”功能**

<div class="columns" style="font-size: 0.95em;">
<div>

根据我们刚才的代码审查，我们已经明确了第一个需要解决的问题：`/look` 指令没有显示出口信息。

现在，我们的“代码审查会”就正式进入了议题一：**实现出口显示功能**。

作为“首席技术官”，你的任务就是将这个发现，转化为一个清晰、可执行的需求，交给你的“AI程序员”。

这一步，是**将问题转化为行动**的关键。

</div>
<div style="font-size: 0.9em;">

> **我们给AI的需求单 (Prompt):**
>
> 请帮我写一个Python函数，名为 `show_exits`。
>
> 1.  它接收 `world` 和 `player_location` 作为参数。
> 2.  它需要检查当前地点的 `exits` 字典。
> 3.  如果字典不为空，就打印一个类似 '此地出口: east(chaguan), south(market)' 格式的字符串。
> 4.  如果字典为空，则不打印任何内容。
> 5.  最后，请修改 `handle_look` 函数，在其中调用你新创建的 `show_exits` 函数。

</div>
</div>

<!--
- **类型**: 逐字稿
- **内容**: |
  好了，刚才我们通过代码审查，发现`/look`指令缺少了显示出口的关键功能。
  现在，我们的代码审查会就进入了第一个议题：如何实现这个功能。
  作为“首席技术官”，我们不能只发现问题，更要能定义问题，并给出解决方案。我们的任务，就是把“功能缺失”这个发现，转化为一个清晰、可执行的需求，就像右边这样，交给我们的“AI程序员”。
  我们明确要求它函数叫什么名字、接收什么参数、完成哪些逻辑步骤，最后，还要求它把新函数集成到旧的`handle_look`函数里。
  这个过程，就是把问题转化为行动的关键一步。
-->

<!--
- **类型**: 教学设计
- **内容**: |
  ### 教学时间: 2分钟
  ### 审查会开题：将问题转化为需求
  本页的核心目标是承上启下，教学员在发现了具体问题后，如何扮演“CTO”或“项目经理”的角色，将一个模糊的“问题”，转化为一个清晰、可执行、结构化的“需求”，并将其作为Prompt下达给AI。

  **核心要点**:
  1.  **转化思维**: 明确教学从“发现问题”到“定义需求”这一关键的思维转变过程。
  2.  **强化角色**: 再次强调“CTO”的职责——不仅要发现问题，更要能规划解决方案和分派任务。
  3.  **示范专业Prompt**: 右侧的“需求单”是一个高质量Prompt的范例，它本身就在教授如何编写包含函数名、参数、逻辑步骤和集成要求的、完整的开发指令。
-->

<!--
- **类型**: 解释
- **内容**: |
  ### 从问题到需求的转化
  在软件开发中，从“发现问题”到“定义需求”，是一个至关重要的思维过程。

  - **问题 (Problem)**: “`/look`不显示出口”，这是一个对现状的观察。
  - **需求 (Requirement)**: “系统应该提供一个`show_exits`函数，它能获取出口数据，并按指定格式打印出来”，这是一个对未来解决方案的、可执行的描述。

  能否完成这种从模糊的“问题”到清晰的“需求”的转化，是区分普通用户和专业产品经理/项目经理/开发者的关键能力之一。

  我们在这里编写的Prompt，本质上就是在撰写一份小型的“**软件需求规格说明书 (Software Requirements Specification, SRS)**”。
-->

---

## **“挑战模板”：如何激发AI的“潜力”**

在“代码审查会”的第二步和第三步，我们可以使用一些强大的“挑战模板”来引导AI。

### **第二步：挑战替代方案**
> - “这段代码可以工作，但感觉有点啰嗦。有没有更**简洁**或更**优雅**的写法？”
> - “除了这种方法，还有没有其他实现这个功能的**不同思路**？”
> - （针对特定语言）“有没有更‘**Pythonic**’（或‘Javascipt-like’）的写法？”

### **第三步：要求对比分析**
> - “请帮我分析一下刚才你提供的**方案A**和**方案B**。”
> - “这两种方案，它们各自的**优点和缺点**是什么？”
> - “在**可读性**和**执行效率**方面，它们各有什么表现？”
> - “对于初学者来说，你更推荐哪一种？为什么？”

<!--
- **类型**: 逐字稿
- **内容**: |
  拿到初稿后，我们就进入了第二步和第三步。这时，我们可以使用一些非常强大的“挑战模板”来激发AI的潜力。
  在第二步，挑战替代方案时，你可以问：“有没有更简洁或更优雅的写法？”或者“有没有其他不同的思路？”如果你知道这门语言的一些特性，还可以问：“有没有更‘Pythonic’的写法？”（“Pythonic”指的是更符合Python语言风格和哲学的方式）。
  在拿到几种方案后，进入第三步，要求对比分析。你可以直接让AI对比方案A和方案B，问它们各自的优缺点是什么？在可读性和执行效率上有什么不同？甚至，你可以让它站在你的角度思考：“对于初学者，你更推荐哪一种？为什么？”
  这些模板，是开启AI深度思考能力的“钥匙”。
-->

<!--
- **类型**: 教学设计
- **内容**: |
  ### 教学时间: 2分钟
  ### 提供工具：“挑战模板”
  本页旨在为学员提供可以直接复制使用的、高质量的“挑战”和“分析”Prompt模板。这是将理论流程转化为可执行动作的关键一步。

  **核心要点**:
  1. **提供即用工具**: 提供多个可以直接使用的Prompt范例，极大降低学员的实践门槛。
  2. **分类展示**: 将模板分为“挑战替代方案”和“要求对比分析”两类，分别对应流程的第二步和第三步，结构清晰。
  3. **关键词教学**: 模板中的加粗关键词（如“简洁”、“优雅”、“不同思路”、“Pythonic”、“优缺点”等）都是经过精心设计的，能有效激发AI提供高质量的回答，这本身就是一种隐性的Prompt工程教学。
-->

<!--
- **类型**: 解释
- **内容**: |
  ### 语言的“惯用法” (Idiom)
  模板中提到的“**Pythonic**”这个词，指向一个重要的概念：**编程语言的惯用法 (Idiomatic Code)**。

  每种编程语言都有其独特的设计哲学和社区推崇的编码风格。所谓“惯用法”，就是指最能体现该语言特色的、被社区广泛接受为“最佳实践”的写法。

  例如，在Python中：
  - 用`for item in my_list:`遍历，而不是用C语言风格的`for (i=0; i<len; i++)`。
  - 用`str.join()`拼接字符串，而不是在循环里用`+`。
  - 用“列表推导式”`[x*2 for x in my_list]`，而不是写一个完整的`for`循环来创建新列表。

  写出“惯用”的代码，通常意味着代码更简洁、更可读、也可能更高效。向AI询问“更Pythonic”的写法，是我们快速学习一门语言地道用法的捷径。
-->

---

## 审查“初稿”：一个“能跑但不够好”的方案
<div style="font-size: 0.8em;">

假设AI根据我们刚才的需求，给出了以下这个“初稿”方案。

这个方案使用`for`循环来逐个拼接字符串，非常地“老实”和“直接”。

```python
def show_exits(world, player_location):
    exits = world[player_location].get('exits', {})
    if not exits:
        return # 如果没有出口，直接返回
        
    exits_string = "此地出口: "
    parts = []
    for direction, destination in exits.items():
        # 手动将每个部分格式化后添加到列表
        parts.append(f"{direction}({destination})")
    
    # 使用 join 方法连接，但分隔符处理得不够好
    exits_string += ", ".join(parts)
    print(exits_string)
```
**我们的评审意见**：这段代码能跑，但手动创建列表再拼接，看起来有点笨拙，不够“优雅”。我们来挑战一下AI，看看有没有更好的方法。
</div>

<!--
- **类型**: 逐字稿
- **内容**: |
  好了，假设我们的“AI程序员”非常听话，根据我们刚才的需求单，给出了这样一个“初稿”方案。
  这个函数用一个`for`循环，遍历出口字典，把每个出口的描述添加到一个列表里，最后用join方法拼接起来。
  这段代码能跑吗？完全能跑，而且也完成了我们在需求里提出的所有任务。
  但是，作为“首席技术官”，我们的“代码品味”告诉我们，这段代码看起来有点笨拙，不够“优雅”。特别是为了拼接字符串，还特意创建了一个中间列表`parts`，感觉不够直接。
  所以，我们决定，就这段代码，向AI发起一次挑战，看看有没有更好的方法。
-->

<!--
- **类型**: 解释
- **内容**: |
  ### 字符串拼接的效率问题
  在很多编程语言（包括Python）中，字符串都是“**不可变 (Immutable)**”的。这意味着一旦一个字符串被创建，它的内容就不能被修改。

  当我们执行`exits_string += ...`这样的操作时，程序并不是在修改原有的`exits_string`。实际上，它是在内存中创建了一个**全新的字符串**，这个新字符串是旧字符串和要拼接内容的总和，然后让`exits_string`这个变量名指向这个新的字符串对象。

  如果在循环中大量进行这样的操作，就会频繁地创建和销毁字符串对象，带来不必要的内存开销和性能损耗。虽然在我们的这个小例子中影响微乎其微，但在需要处理成千上万个字符串拼接的场景下，这就成了一个必须优化的性能问题。这也是为什么专业的程序员会倾向于使用`.join()`这样的高效方法。
-->

---

## **动手环节(1/2)：挑战AI，寻求更优方案**
<div style="font-size: 0.8em;">

现在，让我们向AI发起挑战。

### **第一步：获取“初稿”**
（我们假设上一页的代码就是AI给我们的“初稿”。）

### **第二步：发起“挑战”**
将上一页的`show_exits`函数代码和以下“挑战Prompt”一起发给AI：

> **挑战Prompt (1/2):**
>
> 这是我们目前用于显示出口的Python函数。它能够正常工作。
> ```python
> (在此处粘贴上面的show_exits函数代码)
> ```
>
> 这段代码使用`for`循环来拼接字符串，我觉得有点啰嗦。请问有没有更**简洁**、更“**Pythonic**”的方法来重写这个函数？

**观察AI的回答**：AI很可能会给出一个使用`str.join()`方法和“列表推导式”的、更高级的方案。
</div>

<!--
- **类型**: 逐字稿
- **内容**: |
  现在，请大家动手操作。可以直接使用我们为大家准备的第11节课的起始代码。
  第一步获取初稿我们已经完成了，就用上一页那段`for`循环的代码。
  现在进入第二步：发起挑战。
  请大家复制上一页的`show_exits`函数代码，然后连同我们这里的“挑战Prompt”一起发给AI。
  我们的Prompt很直接：“这段代码能用，但我觉得有点啰嗦。有没有更简洁、更‘Pythonic’的写法？”
  发送之后，观察AI的回答。它很可能会给你一个使用了`str.join()`和“列表推导式”的、看起来更酷的方案。
-->

<!--
- **类型**: 教学设计
- **内容**: |
  ### 教学时间: 4分钟
  ### 动手环节：挑战AI，寻求更优方案
  本页是动手实践环节，旨在引导学员实践“AI代码审查流程”的第二步——向AI发起挑战，寻求替代方案。

  **核心要点**:
  1. **实践流程**: 将理论流程转化为具体的动手指令。
  2. **示范Prompt**: 提供的“挑战Prompt”是一个很好的范例，教会学员如何清晰地表达“对现有代码不满意，并希望得到更简洁、地道的方案”这一诉求。
  3. **建立预期**: 明确告知学员，AI可能会给出一个使用`.join()`和“列表推导式”的更高级方案，为下一步的学习做铺垫。
-->

<!--
- **类型**: 解释
- **内容**: |
  ### 为什么要把代码粘贴回去？
  在与AI的对话中，即使是在同一个会话里，将你正在讨论的**核心代码上下文**重新粘贴到Prompt中，也是一个非常好的习惯。

  **原因**:
  1.  **确保上下文精确**: AI的“注意力”是有限的。在一个长对话中，它可能会“忘记”或“混淆”之前的代码细节。把代码贴回去，可以确保AI的注意力重新聚焦在你指定的、最准确的代码版本上。
  2.  **避免歧义**: 如果不贴代码，直接说“重构刚才的函数”，AI可能会基于一个它记忆中不准确的版本进行重构，导致结果不符合你的预期。
  3.  **便于溯源**: 当你回顾聊天记录时，一个包含了完整代码上下文的Prompt，能让你一目了然地知道当时你们在讨论什么，便于复盘和学习。

  这是一种用“冗余”换取“精确性”的有效策略。
-->

---

## **动手环节(2/2)：要求AI“对比分析”**
<div style="font-size: 0.75em;">

AI给出了一个看起来更“酷”的新方案，但我们可能看不懂，也不知道它好在哪里。现在，进入审查会的第三步。

**新方案可能的样子：**
```python
def show_exits_pythonic(world, player_location):
    exits = world[player_location].get('exits', {})
    if not exits:
        return
        
    # 使用列表推导式和join方法
    exit_parts = [f"{direction}({destination})" for direction, destination in exits.items()]
    exits_string = "此地出口: " + ", ".join(exit_parts)
    
    print(exits_string)
```

> **挑战Prompt (2/2):**
>
> 很好，你给出的这个新方案看起来非常简洁。
> 1.  请先用初学者能听懂的语言，解释一下 `[f"{...}" for ... in ...]` 和 `.join()` 分别是什么意思，它们是如何工作的？
> 2.  然后，请从**可读性**和**性能**两个角度，详细对比分析“for循环方案”和“join方案”各自的优缺点。
</div>

<!--
- **类型**: 逐字稿
- **内容**: |
  AI给出的新方案，比如这个使用了列表推导式和join方法的版本，看起来确实更酷、更简洁，但我们很可能看不懂。
  看不懂没关系，这恰恰是最好的学习机会！我们不能止步于此，而是要进入审查会的第三步：要求AI对比分析。
  我们可以向AI发出这样的指令：“很好，这个新方案很简洁。但请先用初学者能听懂的语言，给我解释一下这些新语法是什么意思。然后，再从可读性和性能两个角度，详细对比分析一下新旧两种方案的优缺点。”
  这个Prompt，体现了我们利用AI进行自主学习的核心思想：不仅让AI做事，更要让AI成为我们的“老师”。
-->

<!--
- **类型**: 教学设计
- **内容**: |
  ### 教学时间: 5分钟
  ### 动手环节：要求AI“对比分析”
  本页是核心实践环节，旨在引导学员实践审查流程的第三步——要求AI对比分析方案。更重要的是，示范了如何利用AI作为“老师”，来帮助自己理解看不懂的新知识。

  **核心要点**:
  1. **利用AI学习**: Prompt的核心设计在于，它不仅要求AI对比方案，还首先要求AI“用初学者能听懂的语言”解释新方案中的语法。这体现了“利用AI进行自主学习”的核心思想。
  2. **结构化提问**: Prompt中的提问是结构化的，要求AI从“可读性”和“性能”两个角度进行分析，这能引导AI给出更全面、更有深度的回答。
  3. **学以致用**: 让学员将在本节课学到的“挑战模板”立刻应用于实践中。
-->

<!--
- **类型**: 解释
- **内容**: |
  ### 列表推导式 (List Comprehension)
  `[f"{...}" for ... in ...]` 是一种非常“Pythonic”的语法，叫做“**列表推导式**”。它提供了一种从一个已有的列表（或其他可迭代对象）创建新列表的简洁方式。

  它的基本结构是 `[expression for item in iterable]`。

  例如，`exit_parts = [f"{direction}({destination})" for direction, destination in exits.items()]` 这行代码，等价于以下`for`循环：
  ```python
  exit_parts = []
  for direction, destination in exits.items():
      part = f"{direction}({destination})"
      exit_parts.append(part)
  ```
  可见，列表推导式将一个三四行的循环，压缩到了一行内，使得代码更紧凑。

  ### `str.join()` 方法
  这是一个字符串方法，它的作用是将一个“可迭代对象”（如列表）中的所有元素，用调用它的那个字符串作为“胶水”连接起来，形成一个单一的、新的字符串。
  例如，`", ".join(['a', 'b', 'c'])` 的结果就是 `'a, b, c'`。
-->

---

## **AI的分析报告：在“权衡”中学习**
<div style="font-size: 0.8em;">

在收到你的指令后，AI会为你生成一份详细的“**技术选型分析报告**”。

<div class="columns" style="font-size: 0.85em;">
<div>

### **方案A: `for`循环**
- **优点**:
  - **逻辑直白**：对于初学者来说，`for`循环的“挨个处理”逻辑非常清晰，易于理解和调试。
- **缺点**:
  - **代码冗长**：需要先初始化一个空字符串，然后在循环中反复修改它，代码行数较多。
  - **性能略低**：在处理大量字符串拼接时，由于字符串的不可变性，每次`+=`操作都可能生成新的字符串对象，理论上性能较差。

</div>
<div>

### **方案B: `.join()`方法**
- **优点**:
  - **代码简洁**：将循环和格式化操作压缩到一行（列表推导式）中，代码非常紧凑。
  - **性能更优**：`.join()`方法在内部实现上经过优化，拼接大量字符串时效率更高。
  - **意图明确**：代码本身就清晰地表达了“我要把一堆东西用逗号连接成一个字符串”的意图。
- **缺点**:
  - **可读性稍差**：对于不熟悉“列表推导式”的初学者来说，可能需要一点时间来理解其语法。

</div>
</div>

<div class="insight">

💡 **你的决策**：通过阅读这份报告，你不仅学会了新知识，更重要的是，你现在可以基于清晰的利弊分析，为你的项目做出明智的**架构决策**了！（例如：在当前阶段，我们更看重可读性，所以暂时保留`for`循环方案。）
</div>
</div>

<!--
- **类型**: 样式替换
- **版本**: [handout, teacher]
- **查找**: |
    <div class="columns" style="font-size: 0.85em;">
- **替换**: |
    <div class="columns styled-div" style="font-size: 0.7em;">
-->

<!--
- **类型**: 样式替换
- **版本**: [handout, teacher]
- **查找**: |
    <div class="insight">
- **替换**: |
    <div class='insight' style="margin-top: 1rem;font-size: 0.6em;">
-->

<!--
- **类型**: 逐字稿
- **内容**: |
  在收到你的分析指令后，AI就会为你生成一份类似这样的“技术选型分析报告”。
  它会告诉你，方案A，也就是`for`循环，优点是逻辑直白，初学者容易懂；缺点是代码冗长，性能也略差。
  然后它会告诉你，方案B，也就是`.join()`方法，优点是代码简洁、性能更优、意图更明确；缺点是对于不熟悉列表推导式的初学者来说，可读性稍差。
  最关键的是，通过阅读这份报告，你不仅学会了列表推导式和`.join()`这些新知识，更重要的是，你现在拥有了在不同方案之间进行“权衡”的能力，并可以基于你的项目需求，做出明智的“架构决策”。
  比如，你完全可以决定：“虽然方案B更酷，但在我们这个学习阶段，可读性更重要，所以我选择暂时保留更易懂的`for`循环方案。” 做出这个决策，意味着你已经是一个真正的“决策者”了。
-->

<!--
- **类型**: 教学设计
- **内容**: |
  ### 教学时间: 3分钟
  ### 学习“权衡”：阅读AI的分析报告
  本页旨在通过展示一份AI生成的、结构化的“技术选型分析报告”，引导学员学习如何在不同技术方案间进行“权衡(Trade-off)”，这是工程师和架构师的核心素养。

  **核心要点**:
  1. **展示成果**: 将AI可能生成的分析报告结构化地展示出来，让学员看到上一步操作的价值。
  2. **引入“权衡”思想**: 明确点出，技术选型并非“非黑即白”，而是在不同维度（如可读性 vs. 性能）之间寻找最适合当前需求的平衡点。
  3. **培养决策能力**: 在“insight”部分，明确点出本环节的最终目的不是“找到唯一正确的答案”，而是学会“做决策”的能力，这是一种更高阶的工程思维。
-->

<!--
- **类型**: 解释
- **内容**: |
  ### 工程中的权衡 (Trade-offs)
  在软件工程乃至所有工程领域，几乎不存在“完美”的解决方案。所有的决策都是在相互冲突的约束条件之间进行“**权衡**”的结果。

  常见的权衡包括：
  - **时间 vs. 空间**: 算法是运行得更快，还是占用内存更少？
  - **开发速度 vs. 运行性能**: 是快速推出一个能用的版本，还是花更多时间去优化性能？
  - **简洁性 vs. 明确性**: 是用一行复杂的代码实现功能，还是用五行简单但清晰的代码？（我们例子中的`.join()` vs. `for`循环）
  - **灵活性 vs. 简单性**: 是构建一个能适应未来各种变化的复杂框架，还是只实现一个满足当前需求的简单方案？

  一个成熟的工程师或架构师，其核心价值就在于能够深刻理解项目的核心需求，并基于这些需求，在各种权衡中做出最明智的、最合适的决策。本节课的练习，就是你作为“决策者”的第一次实践。
-->

---

## **本节总结：从“使用者”到“决策者”**

<div class="columns ratio-6-4">
<div style="font-size: 0.75em;">

在本节课，我们通过“AI代码审查会”，完成了一次至关重要的思维升级。

- **一个核心认知：代码有“品味”**
  - 我们认识到，代码不仅要“能跑”，更要追求“优雅”，即良好的可读性和简洁性。

- **一套审查流程：挑战与分析**
  - 掌握了通过“挑战替代方案”和“要求对比分析”来提升AI代码质量的标准化流程。

- **一种决策能力：权衡与取舍**
  - 你不再被动接受AI的第一个答案，而是学会了在不同方案的优缺点之间进行**权衡(Trade-off)**，并做出最适合当前项目需求和团队能力的**架构决策**。

你已经从一个AI工具的“使用者”，成长为能驾驭AI、并为技术方案最终拍板的“**决策者**”。

</div>
<div class="align-middle-center">

![一个宝箱，里面装着一个天平（代表权衡）、一份分析报告和一个决策者印章的图标 width:400px](image/2025-11-21-01-16-16.png)

</div>
</div>

<!--
- **类型**: 样式替换
- **版本**: [handout, teacher]
- **查找**: |
    <div style="font-size: 0.75em;">
- **替换**: |
    <div class="styled-div" style="font-size: 0.6em;">
-->

<!--
- **类型**: 逐字稿
- **内容**: |
  我们来总结一下本节课的收获。
  通过“AI代码审查会”，我们完成了一次至关重要的思维升级。
  我们建立了一个核心认知：代码是有“品味”的，我们不仅要让它“能跑”，更要追求“优雅”。
  我们掌握了一套审查流程：通过“挑战”和“分析”，系统性地提升AI产出代码的质量。
  最重要的是，我们获得了一种决策能力：权衡与取舍。你不再被动接受AI的第一个答案，而是学会在不同方案的优缺点之间进行权衡，并做出明智的架构决策。
  祝贺大家，你们已经从一个AI工具的“使用者”，成长为能驾驭AI、并为技术方案最终拍板的“决策者”！
-->

<!--
- **类型**: 教学设计
- **内容**: |
  ### 教学时间: 1分钟
  ### 总结：从“使用者”到“决策者”
  本页旨在通过结构化的清单和可视化的“宝箱”，为学员系统性地总结本节课在认知、流程和能力上的核心收获，并强化其“决策者”的新身份。

  **核心要点**:
  1. **多维度总结**: 从“认知（品味）”、“流程（审查）”、“能力（决策）”三个维度进行总结，层次清晰。
  2. **关键词强化**: 再次强调“品味”、“权衡”、“决策者”等本节课的核心关键词。
  3. **角色升华**: 明确指出学员完成了从“使用者”到“决策者”的身份转变，给予强烈的价值肯定。
-->

<!--
- **类型**: 解释
- **内容**: |
  ### 批判性思维在AI时代的重要性
  本节课的核心，是培养在人机协作时代的“**批判性思维 (Critical Thinking)**”。

  批判性思维不是指“批评”或“否定”，而是指对信息和观点进行主动的、系统的、深入的分析、评估和综合，从而形成自己理性判断的能力。

  当面对AI这个强大的“信息源”时，批判性思维变得前所未有的重要：
  - **不盲从**: 不把AI的第一个答案当作最终答案。
  - **会提问**: 知道如何通过提问来挑战AI，发掘更深层次的信息和更多可能性。
  - **能判断**: 能够基于自己的目标和价值观，在AI提供的多种方案中进行权衡和决策。

  这节课你所学习的“代码审查”流程，本质上就是一次在编程领域应用“批判性思维”的完整实践。
-->

---

## **下一步预告：模块终极项目**

<div class="columns ratio-6-4">
<div style="font-size: 0.9em;">

祝贺你！至此，你已经掌握了模块三的所有核心人机协作技能：

- **封装代码 (函数)**
- **修复错误 (调试)**
- **提升质量 (审查)**

你已经具备了作为一名“**AI开发主管**”的全部核心素养。

在模块三的最后一节课，我们将迎来一个全新的、更贴近现实工作场景的**终极挑战**。

我们将综合运用本模块学到的所有知识，指挥AI完成一个实用、完整的“**批量文件整理助手**”项目。这将是你“驾驭”AI能力的最终试炼！

</div>
<div class="align-middle-center">

![一个工具箱，里面装着函数、Bug和审查的图标，旁边是一个即将开始的大型项目蓝图 width:400px](image/2025-11-21-00-12-59.png)

</div>
</div>

<!--
- **类型**: 逐字稿
- **内容**: |
  祝贺大家！到今天为止，你们已经掌握了模块三的所有核心人机协作技能：用函数来封装代码，用调试来修复错误，用审查来提升质量。
  可以说，你已经具备了作为一名“AI开发主管”的全部核心素养。
  在下一节课，也就是我们模块三的最后一节课，我们将迎来一个全新的、更贴近我们老师现实工作场景的终极挑战。
  我们将综合运用本模块学到的所有知识，指挥AI完成一个非常实用的“批量文件整理助手”项目。这将是你作为“AI开发主管”，驾驭AI能力的最终试炼！
  请大家保持期待，我们下节课见！
-->

<!--
- **类型**: 教学设计
- **内容**: |
  ### 教学时间: 1分钟
  ### 承前启后：预告模块终极项目
  本页作为课程结尾，核心是承上启下。通过系统性地总结模块三已学的全部核心技能，并预告下一节课的“终极挑战”，来激发学员的成就感和学习期待。

  **核心要点**:
  1. **总结模块技能**: 将本模块的三个核心技能（函数、调试、审查）进行总结，并将其统一到“AI开发主管”的新角色下，让学员对自己的能力成长有整体性认知。
  2. **建立终极期待**: 将下一节课定位为“终极挑战”和“最终试炼”，并预告一个全新的、更具实用价值的项目“批量文件整理助手”，最大限度地激发学员的参与热情。
-->

<!--
- **类型**: 解释
- **内容**: |
  ### Capstone项目
  我们下一节课的“终极项目”，在教育领域通常被称为“**顶点项目 (Capstone Project)**”。

  Capstone项目是一门课程或一个学习阶段的集大成者，它要求学生：
  - **综合运用**: 将该阶段学习的所有（或大部分）知识和技能，应用于一个相对复杂的、真实的项目中。
  - **自主探索**: 项目通常具有一定的开放性，需要学生自己做出设计决策和技术选型。
  - **成果导向**: 最终产出一个完整的、可展示的“作品”。

  通过Capstone项目，学生能将零散的知识点串联成一个有机的整体，获得解决综合性问题的宝贵经验，并收获巨大的成就感。我们课程的每个模块收官项目，以及最终的大作业，都借鉴了Capstone项目的设计思想。
-->
