---
marp: true
theme: default
paginate: true
size: 16:9
---

<style>
/* --- 布局辅助样式 --- */
.columns {
  display: grid;
  grid-template-columns: repeat(2, minmax(0, 1fr));
  gap: 1rem;
}
.columns pre code {
  white-space: pre-wrap !important;
  overflow-wrap: break-word !important;
}
/* --- 列表缩进样式修正 --- */
ul, ol {
  padding-inline-start: 25px; /* 减小列表的左侧缩进 */
}
.columns.ratio-4-6 { grid-template-columns: 4fr 6fr; }
.columns.ratio-6-4 { grid-template-columns: 6fr 4fr; }
.columns.ratio-3-7 { grid-template-columns: 3fr 7fr; }
.columns.ratio-7-3 { grid-template-columns: 7fr 3fr; }
.align-top    { display: flex; align-items: flex-start; }
.align-middle { display: flex; align-items: center; }
.align-bottom { display: flex; align-items: flex-end; }
.align-left   { display: flex; justify-content: flex-start; }
.align-center { display: flex; justify-content: center; }
.align-right  { display: flex; justify-content: flex-end; }
.align-top-left     { display: flex; justify-content: flex-start; align-items: flex-start; }
.align-top-center   { display: flex; justify-content: center;  align-items: flex-start; }
.align-top-right    { display: flex; justify-content: flex-end;   align-items: flex-start; }
.align-middle-left  { display: flex; justify-content: flex-start; align-items: center; }
.align-middle-center{ display: flex; justify-content: center;  align-items: center; }
.align-middle-right { display: flex; justify-content: flex-end;   align-items: center; }
.align-bottom-left  { display: flex; justify-content: flex-start; align-items: flex-end; }
.align-bottom-center{ display: flex; justify-content: center;  align-items: flex-end; }
.align-bottom-right { display: flex; justify-content: flex-end;   align-items: flex-end; }
.tip {
  background-color: #f0f8ff;
  border-left: 5px solid #1e90ff;
  padding: 15px;
}
.insight {
  background-color: #eefcff; 
  border-left: 5px solid #17a2b8; 
  padding: 15px; 
}
.key-point {
  background-color: #fffbe6; 
  border-left: 5px solid #ffc107; 
  padding: 15px; 
}
.tip p, .tip li,
.insight p, .insight li,
.key-point p, .key-point li {
  font-size: inherit !important;
}
.styled-div p, 
.styled-div li, 
.styled-div ol, 
.styled-div ul, 
.styled-div blockquote {
  font-size: inherit !important;
}
</style>

![bg blur:3px brightness:60%](../../../lectures/images/2025-11-13-18-53-14.png)

<style scoped>
h1{
  color: #F5F5F5; /* 设置文字颜色为白色 */
  text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.8); /* 添加一个柔和的深色阴影 */
}
h2 {
  color: #E0E0E0; /* 设置文字颜色为白色 */
  text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.8); /* 添加一个柔和的深色阴影 */
}
.course-title {
  position: absolute;
  top: 60px;
  left: 80px;
  background-color: rgba(0, 0, 0, 0.4);
  color: #fff;
  padding: 8px 15px;
  border-radius: 5px;
  font-size: 22px;
  font-weight: bold;
  letter-spacing: 1px;
  border-left: 5px solid #4CAF50; /* 用一条强调色作为装饰 */
}
</style>

<div class="course-title">AI赋能软件开发</div>

# 模块二：与AI对话——学习编程的核心规则
## 第6节课：赋予世界规则——指令解析与条件判断

<div style="position: absolute; bottom: 40px; left: 80px; color: rgba(255, 255, 255, 0.8); font-size: 18px; font-family: sans-serif;">
南昌大学计算机系 黎鹰
</div>

<!--

（音乐）各位老师好！欢迎回到我们的课程。
在上一节课，我们扮演“世界架构师”，成功地用变量和字典为我们的武侠世界绘制了一幅静态的“蓝图”。
但那个世界是死的，它只是一个只能看、不能玩的“固定剧本”。
这节课，我们将迈出关键一步，学习如何为这个世界注入规则。我们将学会如何让程序听懂我们的指令，并做出判断和选择。
-->

---

## **回顾：一个“固定剧本”的世界**

<div class="columns ratio-6-4">
<div style="font-size: 0.85em;">

在上一节课，我们取得了巨大的进步！

我们成功地用“字典”绘制了一幅宏大的“世界蓝图”，并让玩家“降生”在了世界上。

但是，我们的程序就像一个“**固定剧本**”。
- **情节是固定不变的**：程序从第一行开始，沿着唯一的路径执行到最后一行，然后就结束了。
- **无法响应玩家**：它不能暂停下来等待我们的指令，更不能根据我们的想法产生任何分支或改变。

这种**单向、不可交互的执行流程**，是它无法成为真正“游戏”的根本原因。

**我们如何让程序“暂停”下来，聆听我们的指令，并据此走向不同的未来呢？**

</div>
<div>

![一个机器人只能沿着一条直线路径行走，无法拐弯 width:400px](../../../lectures/images/2025-11-14-00-07-39.png)

</div>
</div>

<!--

让我们再次明确一下上一节课结束时我们面临的“痛点”。
我们用字典构建了可以变得很宏大的世界蓝图，结构清晰，易于扩展。但是，当我们运行程序时，它只是把开场白打印出来，然后就结束了。
它就像一个只会走直线的机器人，无法根据路况拐弯。它更像一本只能从头读到尾的小说，而不是一个可以玩的“游戏”。
问题的根源在于，我们的程序是“单向”的，是“不可交互”的。
所以，我们这节课要解决的核心问题就是：如何让程序停下来，听我们说话，并且根据我们说的话，做出不同的反应？
-->

---

## **本节课目标：指挥AI构建“规则”与“选择”**

为了让世界“活”起来，我们必须为它建立“**规则**”，让它能根据情况做出“**选择**”。

本节课，我们将学习“指挥AI的三大核心指令”中的第二个：

### **条件判断 (If-Else)**
- **作用**：在程序中建立“**决策点**”，赋予程序“**选择**”的能力。
- **你的新能力**：
  1. **定义“规则”**：学会用“如果玩家输入的是`/go`指令，就...”的结构，向AI清晰地描述游戏规则。
  2. **审查“逻辑”**：审查AI代码中的“决策逻辑”是否符合你的游戏设计。

**最终，你将能指挥AI，为你的武侠世界创造出第一个“指令解析器”！**

<!--

好，为了解决刚才的问题，我们这节课的目标非常明确。
我们要学习“三原色”中的第二个——条件判断。
它的作用，就是在我们的程序里，建立一个个“决策点”，让程序拥有“选择”的能力。
通过这节课，你将获得两项新能力：第一，学会如何向AI清晰地描述游戏规则，比如“如果玩家输入/go，就...”。第二，也是更重要的，当你拿到AI生成的代码时，你将有能力去审查其中的“决策逻辑”是否符合你的设计。
课程结束时，我们将共同指挥AI，创造出我们武侠世界的第一个核心部件——“指令解析器”。
-->

---

## **情景带入：我们身边的“游戏规则”**

其实，“如果...就...”的决策规则，早已贯穿我们玩过的所有游戏中。

- **角色扮演游戏**
  - **如果** `玩家选择的职业是“法师”`，**就** `初始智力+10`。
  - **如果** `玩家的等级低于10级`，**就** `无法进入“高级地下城”`。

- **策略游戏**
  - **如果** `我方单位是“骑兵”且攻击目标是“弓箭手”`，**就** `伤害加成50%`。
  - **如果** `地图上的资源“木材”少于100`，**就** `高亮显示所有树木`。

这些游戏规则，正是我们为“游戏世界”这个**问题**所建立的**抽象规则**。编程的核心，就是将我们为现实世界中各类问题所建立的规则，用代码精确地实现出来。

<!--

其实，“如果...就...”这种条件判断的逻辑，我们每个人都早已烂熟于心。
回想一下我们玩过的任何一款游戏。比如角色扮演游戏里，“如果你的职业是法师，初始智力就加10”。“如果你的等级不够，就不能进某个地图”。
再比如策略游戏里，“如果兵种相克，伤害就有加成”。“如果资源快没了，系统就会给你高亮提示”。
这些我们习以为常的游戏规则，本质上都是一条条的条件判断。编程的核心工作之一，就是把我们为现实问题设计的这些规则，用代码精确地翻译给计算机听。
-->

---

## **概念拆解：程序的“判断题”**

计算机是如何做出“判断”的呢？在执行 `if` 语句前，它会先求解一个答案只有 **“真” (True)** 或 **“假” (False)** 的“判断题”。

<div class="columns" style="font-size: 0.9em;">
<div>

**例1：判断玩家指令 (文本比较)**
`command == "/quit"`
这句代码是在**提问**：
> “变量 `command` 里的文本，**是不是等于** `"/quit"` 这个词？”

- 若 `command` 是 `"/quit"`，答案为 **`True`**。
- 若 `command` 是 `"/look"`，答案为 **`False`**。

</div>
<div>

**例2：判断玩家等级 (数值比较)**
`player_level >= 10`
这句代码也是在**提问**：
> “变量 `player_level` 里的数字，**是不是大于或等于** `10`？”

- 若 `player_level` 是 `15`，答案为 **`True`**。
- 若 `player_level` 是 `5`，答案为 **`False`**。

</div>
</div>

<div class="insight" style="margin-top: 1rem;">

💡 **核心定义**：`==`(等于)、`!=`(不等于)、`>`(大于)、`<`(小于)、`>=`(大于等于) 这些符号，是程序用来进行“是/非”判断的工具，它们统称为“**比较运算符**”。
</div>

<!--

我们怎么让程序做出‘判断’呢？其实非常简单，我们只需要向它提一个答案只有‘是’或‘否’的‘判断题’。
看左边的例子，`command == “/quit”`。注意，这里是两个等号。它不是在下命令，而是在 提问 。它在问计算机：“`command`这个变量里的内容，是不是等于`/quit`这个词？” 计算机检查后，会给我们一个答案，要么是“真”，要么是“假”。
再看右边的例子，`player_level >= 10`。它同样是在提问：“`player_level`这个变量里的数字，是不是大于或者等于10？” 答案也只能是“真”或“假”。
这些用来提问的符号，比如两个等号、大于号、小于号，就是我们程序里的“判断工具”，它们有个正式的名字，叫“比较运算符”。正是这些简单的“判断题”，构成了所有复杂逻辑的起点。
-->

---

## **核心概念1：布尔值——只有“真”或“假”的世界**

在Python中，`True` 和 `False` 这两个特殊的“答案”，是一种全新的数据类型，叫做“**布尔值 (Boolean)**”。

布尔值是程序世界的逻辑基石，它代表了所有“判断题”的最终结果。

你可以亲自在命令行中运行 `python` 后，将以下代码复制到Python的`>>>`提示符后按回车验证一下：

<div class="columns">
<div>

**代码示例**
```python
# 我们可以直接打印出一个“判断题”的答案
command = "/quit"

print("指令是不是'/quit'?", command == "/quit")

print("指令是不是'/look'?", command == "/look")

print("玩家等级是不是大于10?", 15 > 10)
```

</div>
<div>

**输出结果**
```text
指令是不是'/quit'? True
指令是不是'/look'? False
玩家等级是不是大于10? True
```

</div>
</div>

<!--

我们刚才说的“真”和“假”，在Python里是两个非常特殊的“值”，它们就是`True`和`False`。
它们共同构成了一种全新的数据类型，叫做“布尔值”。这个名字是为了纪念逻辑学大师乔治·布尔。
布尔值，就是所有“判断题”的唯一答案，是整个程序逻辑大厦的基石。
大家可以立刻动手感受一下。在VS Code的终端里输入`python`进入交互环境，然后把左边的代码一行一行地复制进去，看看它的输出结果，是不是和右边一样。你会亲眼看到，`command == "/quit"`这个“问题”，它的“答案”就是`True`。
-->

---

## **核心概念2：布尔的本质——逻辑开关**

“真”与“假”是抽象的逻辑概念。在程序中，它们就像一个最简单的“**逻辑开关**”。

一个开关，只有“**开**”和“**关**”两种状态，绝不可能存在第三种。

- **`True`** 就等同于“**开**”：条件满足，执行这条路。
- **`False`** 就等同于“**关**”：条件不满足，不走这条路，去别处看看。

<div class="align-middle-center">

![一个清晰的拨动式电灯开关，左边是关，右边是开 width:300px](../../../lectures/images/2025-11-13-18-58-04.png)

</div>

我们写的 `if score >= 60:`，本质上就是在检查“及格”这个逻辑开关是否被打开。理解了这一点，`if`语句就变得非常简单。

<!--

布尔值的`True`和`False`听起来有点抽象。我们如何更直观地理解它呢？
我最喜欢的一个比喻，就是把它看成一个最简单的“逻辑开关”，就像我们家里的电灯开关一样。
一个开关，只有“开”和“关”两种状态，不可能有半开半关。
`True`就代表开关是“开”的，表示条件满足了，我们可以走这条路。
`False`就代表开关是“关”的，表示条件不满足，这条路不通，我们得看看有没有别的路可走。
所以，当我们写`if score >= 60`的时候，我们本质上就是在问电脑：“‘及格’这个开关，现在是开着还是关着？”
理解了“逻辑开关”这个比喻，`if`语句的所有秘密就都被你洞悉了。
-->

---

## **核心语法1：用 `If-Else` 搭建第一个“T字路口”**

理解了布尔值和开关，`If-Else` 的工作原理就变得非常简单：**它就是在检查一个“开关”是开着还是关着。** 请将代码复制到Python的>>>提示符后运行，理解一下程序逻辑：

<div class="columns">
<div class="styled-div" style="font-size:0.8em">

**设计逻辑**

> **如果** `玩家输入的指令` 是 `"/quit"`，
> **就** `退出游戏`；
> **否则**，
> **就** `继续游戏`。

**程序中的逻辑**
```python
command = "/go east"

# 计算机算出 command == "/quit" 是 False (开关是关的)
if command == "/quit": 
    # 因为开关是关的，所以这部分代码被跳过
    print("你退出了江湖...")
else: 
    # 程序走到这里，执行这个代码块
    print("游戏继续...")
```

</div>
<div class="align-middle-center" style="flex-direction: column;">

![width:240px](../../../lectures/images/2025-11-13-20-20-13.png)
**决策的可视化流程图**

</div>
</div>

<!--

有了“逻辑开关”这个强大的心智模型，我们来看`if-else`这个最基础的语法。它就是我们程序里的第一个“T字路口”。
看左边的代码。我们先设置指令是`/go east`。然后，`if`语句开始检查`command == "/quit"`这个“开关”。
显然，`/go east`不等于`/quit`，所以这个“开关”是关的（结果是`False`）。
因此，`if`下方的、缩进的代码块被完全跳过，程序根本不会去看它。
然后程序来到`else`这里，`else`的意思就是“否则”，也就是“如果上面的开关是关的，那就走我这条路”。于是，`else`下方的代码被执行，屏幕上打印出“游戏继续...”。
右边的流程图，非常清晰地展示了这个“二选一”的决策过程。
-->

---

## **核心语法2：用 `elif` 搭建“立交桥”**

如果我们的指令不止两种呢？比如，我们需要处理 `/go`, `/look`, `/get` 等多种指令。

这时，我们就需要使用 `elif` (else if的缩写) 来搭建更复杂的“**立交桥**”，进行多轮判断。

<div class="columns">
<div>

**更复杂的指令解析**
（ 请继续复制代码，观察执行结果）
```python
command = "/look"

if command == "/go": # 第1个判断
    print("处理移动逻辑...")
elif command == "/look": # 如果第1个判断为假，则进行第2个判断
    print("处理观察逻辑...")
elif command == "/get": # 如果前2个判断都为假，则进行第3个判断
    print("处理拾取逻辑...")
else: # 如果以上所有判断都为假
    print("无效的指令！")
```

</div>
<div class="align-middle-center" style="flex-direction: column;">

![width:300px](../../../lectures/images/2025-11-13-20-22-16.png)
**“立交桥”的可视化流程图**

</div>
</div>

<!--

T字路口只能解决“二选一”的问题。但我们的游戏指令显然不止两种。我们需要一个更复杂的结构，就像一座“立交桥”，来实现多重判断。
这个工具就是`elif`，它是`else if`的缩写。
我们来看左边的代码。程序会像过关一样，从上到下依次检查。
首先，判断`command`是不是`/go`？不是，跳过。
接着，进入第一个`elif`，判断`command`是不是`/look`？是的！开关打开了。于是，程序执行`elif`下方的代码，打印“处理观察逻辑...”。
最关键的是，一旦有一个“开关”被打开，整个“立交桥”的检查就结束了！后面的`elif`和`else`会被完全跳过。
如果所有`if`和`elif`的开关都是关的，程序最后才会走到`else`这条“默认道路”上。
-->

---

## **核心语法3：用 `and` / `or` 组合判断**

有时，一个简单的“判断题”不足以描述我们的规则。我们需要组合多个条件。

- **`and` (并且)**：要求**所有**子问题都为 `True`，最终答案才是 `True`。
  - `(玩家等级 > 10) and (拥有“公会徽章”)` -> 两个都得满足。

- **`or` (或者)**：只要**任何一个**子问题为 `True`，最终答案就是 `True`。
  - `(职业 == "法师") or (智力 > 15)` -> 满足一个就行。

`and` 和 `or` 就像连词，让我们可以提出更复杂的“判断题”。

<!--

有时，我们的游戏规则会更复杂。比如，“玩家等级大于10级，**并且**拥有公会徽章，才能进入某个副本”。或者，“玩家职业是法师，**或者**智力大于15，就可以学习这个技能”。
为了实现这种复杂的判断，Python提供了两个逻辑连词：`and`和`or`。
`and`非常严格，它要求它连接的所有“判断题”的答案都必须是`True`，最终结果才是`True`。只要有一个是`False`，整个就是`False`。
`or`则非常宽容，只要它连接的“判断题”中，有任何一个的答案是`True`，最终结果就是`True`。
`and`和`or`让我们可以把简单的判断题，组合成复杂的“论述题”。
-->

---

## **模式转换：从“学习语法”到“指挥AI”**

我们已经掌握了 `if-else` 的核心逻辑。从现在开始，我们不再逐行编写代码，而是转换角色，作为“游戏设计师”**通过自然语言指挥AI完成整个程序**。

接下来，我们将通过两步指令，让AI为我们构建出完整的游戏循环和指令解析器。

<div class="insight" style="margin-top: 1rem; font-size:0.9em;">

💡 **请注意：**

1.  **关注“指令”，而非“代码”**：你的核心任务是思考并写下清晰的、给AI的**指令**（Prompt）。
2.  **AI的代码可能包含“超前”内容**：为了让程序完整运行，AI可能会使用我们尚未学过的知识（例如 `startswith()` 方法）。
3.  **学会“忽略”**：你**完全可以忽略**那些看不懂的代码！只需关注AI生成的代码中，和你刚刚学过的 `if-else` 相关的部分即可。
4.  **保持“好奇”**：如果你对“超前”的代码感兴趣，这正是绝佳的预习机会！大胆地复制那段代码，向AI提问：“请用初学者能听懂的语言，解释这段代码是什么意思？”

</div>

<!--

好的，理论知识已经足够了。我们已经掌握了`if-else`的核心逻辑。
从现在开始，我们再次进行“模式转换”。我们不再纠结于语法的细节，而是切换回“游戏设计师”的角色，通过清晰的自然语言指令，指挥我们的AI程序员来完成整个程序。
在接下来的动手环节，请大家特别注意这几点。第一，你的核心任务是写好给AI的“指令”，而不是代码。第二，AI为了让程序跑起来，可能会用一些我们没学过的“超前”知识，比如一个叫`startswith`的方法。第三，对于这些看不懂的代码，你可以完全“忽略”它！我们只关注`if-else`那部分就行。最后，如果你对这些“超前”知识感到好奇，那就大胆地问AI，这是最好的预习方式！
-->

---

## **第一步：让世界“聆听”一次指令**

我们向AI发出第一个指令。这个指令的目标是：让游戏能**执行一次完整的交互**：显示场景、获取指令、并根据最简单的 `/quit` 指令做出反应。

> **我们的指令 (Prompt):**
>
> 请在现有代码基础上进行修改。我需要程序能实现一次完整的单次交互：
> 1.  首先根据 `player_location` 变量，打印出当前地点的描述。
> 2.  然后使用 `input()` 函数来获取玩家的输入，并将输入的内容存入一个名为 `command` 的变量中。
> 3.  最后，使用 `if` 语句判断：如果玩家输入的 `command` 等于 `"/quit"`，就打印 "你退出了江湖..."。

<!--

好了，让我们开始动手。
我们的第一步，是让这个世界能“聆听”我们一次。目标是实现一次完整的交互：显示场景、等待我们输入、然后根据一个最简单的指令`/quit`做出反应。
现在，请大家打开VS Code，在上一节课我们创建的世界地图代码基础上，向你的AI助手，完整地复制并发送这段指令。
注意看这个指令的写法，它非常清晰地分了三步，定义了程序应该做什么，这正是“架构师”的思维方式。
-->

---

## **AI的实现与我们的关注点**

<div style="font-size:0.85em;">

AI根据我们的指令，生成了如下的单次交互脚本（注意：AI生成有一定随机性，内容可能稍有不同）。

```python
# ... (之前的世界定义代码) ...

# 根据 player_location 变量的值，从 world 字典中获取玩家所在地的描述，并打印出来
print("\n=== 武侠世界 ===")
print(world[player_location]['description'])

# 获取玩家输入
command = input("\n请输入指令（输入/quit退出）：")

# 判断玩家输入
if command == "/quit":
    print("你退出了江湖...")  
```

<div class="insight">

✅ **我们的关注点：**

我们看到，程序现在是一个简单的、从上到下执行一次的脚本。`if command == "/quit":` 这一行精确地实现了我们“判断退出指令”的设计意图。这就足够了！

</div>
</div>

<!--

好的，AI应该已经给出了它的代码。我们来看一下。
代码的逻辑和我们的指令完全一致：先打印描述，然后用`input`获取指令，最后用一个`if`语句来判断是不是`/quit`。
现在，请大家把AI生成的完整代码（包括上一节课的`world`字典）复制到一个`.py`文件中，然后运行它。
你会发现，程序打印出地点描述后，就停下来等待你输入了。你输入`/quit`试试，它会打印“你退出了江湖...”。你输入别的任何东西，它会什么也不做就直接结束。
我们成功了！我们的程序第一次“听懂”了我们的话！我们只需要关注`if`这一行，它精确地实现了我们的设计意图。
-->

---

## **第二步：实现完整的指令解析**

<div style="font-size:0.85em;">

很好，我们的程序已经能响应最基础的 `/quit` 指令了。接下来，我们向AI发出第二个指令，要求它在 `if` 语句后面，用 `elif` 和 `else` 补完所有我们设计好的游戏规则，构建一个完整的指令解析器。

> **我们的指令 (Prompt):**
>
> 非常棒！现在请在 `if` 语句后面继续添加 `elif` 和 `else` 分支，来实现对其他指令的解析：
> 1.  如果玩家输入 `"/look"`，就重新打印当前地点的描述。
> 2.  如果玩家输入的是以 `"/go"` 开头的指令（例如 `"/go east"`），就解析出后面的方向。然后检查这个方向是否是当前地点的一个有效出口。
>     - 如果是有效出口，就更新 `player_location` 变量为新的地点ID，并打印一句提示，比如“你来到了[新地点名称]...”。
>     - 如果不是有效出口，就打印“你不能往那个方向走。”
> 3.  对于所有其他无法识别的指令，用 `else` 分支打印“无效的指令！”。

</div>

<!--

第一步成功了，我们信心大增。现在，让我们来完成第二步，构建一个完整的指令解析器。
请大家再次向AI发出指令。这一次，我们的指令更复杂了。我们要求它在刚才的`if`语句后面，用`elif`和`else`来补完其他所有规则。
我们来看一下这个指令。第一条，处理`/look`。第二条，处理`/go`，这里面的逻辑比较复杂，我们甚至用了一个嵌套的“如果...就...”来描述它。第三条，用`else`来处理所有其他情况。
这个Prompt，就是一份优秀的设计文档。现在，把它发给你的AI程序员吧！
-->

---

## **AI的最终代码与审查**

AI迅速迭代生成了包含完整逻辑的、有详细注释的最终代码，质量很高。

<style scoped>
.small-code pre, .small-code code {
  font-size: 0.72em;
  line-height: 0.9;
}
</style>

<div class="small-code">

```python
# ... (前面是没有变化的代码) ...
# 判断玩家输入
if command == "/quit":
    print("你退出了江湖...")
elif command == "/look":
    # 重新打印当前地点的描述
    print(world[player_location]['description'])
elif command.startswith("/go "):
    # 解析方向参数
    direction = command.split(" ", 1)[1]  # 获取/go后面的部分，例如"east"
    
    # 检查这个方向是否是当前地点的一个有效出口
    if direction in world[player_location]['exits']:
        # 更新 player_location 变量为新的地点ID
        new_location = world[player_location]['exits'][direction]
        player_location = new_location
        
        # 打印提示
        print(f"你来到了{new_location}...")
    else:
        # 不是有效出口，打印错误信息
        print("你不能往那个方向走。")
else:
    # 对于所有其他无法识别的指令，打印无效指令提示
    print("无效的指令！")

```

</div>

<!--

好，AI已经生成了最终的代码。我们可以看到，它精确地按照我们的`if-elif-else`设计，实现了对不同指令的判断。
对于`/go`指令，它还使用了一个嵌套的`if-else`来处理“出口有效”和“出口无效”这两种情况。
现在，请大家再次运行完整的代码。试一试输入`/look`，输入一个有效的方向比如`/go east`，再输入一个无效的方向比如`/go north`，最后输入一些胡言乱语。看看程序的反应是否和我们预期的完全一致。
-->

---

## **作为“设计师”的最终审查**

<div class="columns">
<div style="font-size:0.82em">

现在，请扮演“游戏设计师”的角色，对AI生成的最终代码进行**逻辑审查**。

你不需要理解每一行代码的技术细节，但你需要通过输入和输出的内容确认：

-   [✅] `"/quit"` 的逻辑对吗？
-   [✅] `"/look"` 的逻辑对吗？
-   [✅] `"/go"` 的逻辑是否完整？
    -   有没有处理无效方向（比如 `/go north`）？
    -   有没有处理错误指令（比如 `/go` 后面没跟方向）？
-   [✅] 对所有其他指令，是不是提示了“无效指令”？

</div>
<div class="align-middle-center" style="flex-direction: column;">

![AI负责实现，你负责设计和验收 width:400px](../../../lectures/images/2025-11-13-19-01-58.png)

**你的核心价值：代码评审与逻辑验收。** AI负责实现代码，你负责确保代码的逻辑符合你的设计蓝图。

</div>
</div>

<!--

测试完成后，让我们正式地进行一次“代码评审”。
请大家像一个真正的游戏设计师一样，看着左边的这份“验收清单”，逐一确认AI的工作成果。
`/quit`的逻辑对吗？对了。`/look`的逻辑对吗？也对了。
`/go`的逻辑是否完整？我们测试了有效方向和无效方向，都处理了。
对于其他所有指令，是不是都提示了“无效指令”？是的。
非常好！AI程序员通过了我们的验收。
请大家体会一下这个过程。我们虽然没有亲手写大部分代码，但我们定义了规则，并通过测试和审查，最终对代码的质量进行了验收。这就是“设计师”和“架构师”的核心价值。
-->

---

## **价值升华：你是“游戏规则”的唯一制定者**

<div class="columns">

<div>

我们来回顾一下这节课的人机协作流程：
1.  **你 (设计师)**：提出 `/look` 和 `/go` 的核心玩法规则。
2.  **AI (程序员)**：根据你的规则，生成了包含 `if/elif/else` 的代码。
3.  **你 (审查者)**：检查AI的代码逻辑，确保它符合你的预期，没有产生类似“原地踏步”的Bug。

AI能不知疲倦地编写代码，但它没有灵魂，没有世界观。它不知道“光明顶”和“武当山”哪个更应该是正派，也不知道你的游戏中，“/look”一下是否应该消耗体力。

**这些，只有你——游戏世界的设计师和规则的唯一制定者——才能决定。**

</div>
<div class="align-middle-center" style="flex-direction: column;">

![一个艺术家正在为一个巨大的机器人心脏绘制蓝图 width:300px](../../../lectures/images/2025-11-13-19-05-15.png)

<div class="insight" style="margin-top: 0.2rem;">

💡 **AI负责实现，你负责想象。** 你的核心价值，在于为代码注入灵魂——**创造**规则、构建体验、讲述故事。
</div>

</div>
</div>

<!--

让我们再次升华一下。回顾我们这节课的人机协作流程。
第一步，你作为设计师，提出了核心玩法规则。
第二步，AI作为程序员，根据规则生成了代码。
第三步，你作为审查者，检查了代码逻辑。
在这个流程中，我们必须清醒地认识到，AI能做什么，不能做什么。AI可以帮我们实现任何我们描述出来的规则，但它本身没有灵魂，没有世界观。
它不知道你的游戏中，“look”一下是否应该消耗体力。它不知道“华山”和“魔教”哪个是正派。这些，都必须由你，游戏世界规则的唯一制定者，来决定。
AI负责实现，而你，负责想象。你的核心价值，就是为代码注入灵魂：创造规则、构建体验、讲述故事。
-->

---

## **本节课总结：我们获得了什么？**

<div class="columns ratio-6-4">

<div style="font-size: 0.9em;">

在本节课，我们为游戏世界装上了“规则引擎”，你作为“游戏设计师”的核心能力也得到了升级：

- **获得了“规划”能力**
  - 你学会了如何将现实世界的游戏规则，翻译成程序可以理解的 `If-Else` 决策路径。
- **获得了“审查”能力**
  - 你掌握了审查AI代码“设计蓝图”中**核心交互逻辑**的方法，确保AI的决策符合你的设计意图。

你不再只是一个被动的旁观者，而是能主动为你的世界**制定规则、定义交互**的创造者——哪怕目前，这还只是“一瞬间”的交互。

</div>

<div class="align-middle-center">

![width:400px](../../../lectures/images/2025-11-13-19-06-50.png)

</div>

</div>

<!--

好了，让我们来盘点一下这节课的收获。
这节课，我们为游戏世界装上了“规则引擎”。更重要的是，你作为“游戏设计师”的能力得到了升级。
你获得了“规划”能力，学会了如何把脑海中的规则，翻译成程序能理解的`If-Else`决策路径。
你获得了“审查”能力，学会了如何审查AI生成的代码，确保它的逻辑符合你的设计。
你不再只是一个旁观者，而是能主动为你的世界制定规则、定义交互的创造者。虽然，我们目前还只能实现“一瞬间”的交互。
-->

---

## **下一步预告：从“时间切片”到“时间流逝”**

<div class="columns ratio-6-4">

<div style="font-size: 0.9em;">

我们已经能让世界响应我们的指令了！这是一个巨大的进步！

但是，我们的程序依然只能表现世界运转的**一个极短的“时间切片”**。它接收一次指令，执行一次判断，然后整个世界的“时间”就停止了。

**如何让时间真正“流动”起来？**

我们如何为这个世界装上“心跳”，让它不再是执行一次就结束的“切片”，而是能持续运转、让玩家沉浸其中探索的“时间流”？

为了让世界拥有“心跳”，下一节课，我们将学习指挥AI的三大核心指令中的最后一个——**循环**！

</div>

<div class="align-middle-center">

![width:400px](../../../lectures/images/2025-11-13-19-09-28.png)

</div>

</div>

<!--

我们取得了巨大的进步，但离一个真正的游戏，还差最后，也是最关键的一步。
我们现在的程序，只能响应我们一次指令。执行完一次判断后，整个世界的时间就停止了。它只是一个“时间切片”，而不是一条“时间长河”。
如何让时间真正地“流动”起来？如何为我们的世界装上永不停歇的“心跳”？
为了解决这个终极问题，下一节课，我们将学习“三原色”中的最后一个，也是最强大的一个——循环！
感谢大家，我们下节课见！
-->