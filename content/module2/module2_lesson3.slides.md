---
marp: true
theme: default
paginate: true
size: 16:9
---

<style>
/* --- 布局辅助样式 --- */
.columns {
  display: grid;
  grid-template-columns: repeat(2, minmax(0, 1fr));
  gap: 1rem;
}
.columns pre code {
  white-space: pre-wrap !important;
  overflow-wrap: break-word !important;
}
/* --- 列表缩进样式修正 --- */
ul, ol {
  padding-inline-start: 25px; /* 减小列表的左侧缩进 */
}
.columns.ratio-4-6 { grid-template-columns: 4fr 6fr; }
.columns.ratio-6-4 { grid-template-columns: 6fr 4fr; }
.columns.ratio-3-7 { grid-template-columns: 3fr 7fr; }
.columns.ratio-7-3 { grid-template-columns: 7fr 3fr; }
.align-top    { display: flex; align-items: flex-start; }
.align-middle { display: flex; align-items: center; }
.align-bottom { display: flex; align-items: flex-end; }
.align-left   { display: flex; justify-content: flex-start; }
.align-center { display: flex; justify-content: center; }
.align-right  { display: flex; justify-content: flex-end; }
.align-top-left     { display: flex; justify-content: flex-start; align-items: flex-start; }
.align-top-center   { display: flex; justify-content: center;  align-items: flex-start; }
.align-top-right    { display: flex; justify-content: flex-end;   align-items: flex-start; }
.align-middle-left  { display: flex; justify-content: flex-start; align-items: center; }
.align-middle-center{ display: flex; justify-content: center;  align-items: center; }
.align-middle-right { display: flex; justify-content: flex-end;   align-items: center; }
.align-bottom-left  { display: flex; justify-content: flex-start; align-items: flex-end; }
.align-bottom-center{ display: flex; justify-content: center;  align-items: flex-end; }
.align-bottom-right { display: flex; justify-content: flex-end;   align-items: flex-end; }
.tip {
  background-color: #f0f8ff;
  border-left: 5px solid #1e90ff;
  padding: 15px;
}
.insight {
  background-color: #eefcff; 
  border-left: 5px solid #17a2b8; 
  padding: 15px; 
}
.key-point {
  background-color: #fffbe6; 
  border-left: 5px solid #ffc107; 
  padding: 15px; 
}
.tip p, .tip li,
.insight p, .insight li,
.key-point p, .key-point li {
  font-size: inherit !important;
}
.styled-div p, 
.styled-div li, 
.styled-div ol, 
.styled-div ul, 
.styled-div blockquote {
  font-size: inherit !important;
}
</style>

![bg blur:3px brightness:60%](../../../lectures/images/2025-11-13-20-33-40.png)

<style scoped>
h1{
  color: #F5F5F5; /* 设置文字颜色为白色 */
  text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.8); /* 添加一个柔和的深色阴影 */
}
h2 {
  color: #E0E0E0; /* 设置文字颜色为白色 */
  text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.8); /* 添加一个柔和的深色阴影 */
}
.course-title {
  position: absolute;
  top: 60px;
  left: 80px;
  background-color: rgba(0, 0, 0, 0.4);
  color: #fff;
  padding: 8px 15px;
  border-radius: 5px;
  font-size: 22px;
  font-weight: bold;
  letter-spacing: 1px;
  border-left: 5px solid #4CAF50; /* 用一条强调色作为装饰 */
}
</style>

<div class="course-title">AI赋能软件开发</div>

# 模块二：与AI对话——学习编程的核心规则
## 第7节课: 赋予世界“心跳”——驱动游戏世界的循环

<div style="position: absolute; bottom: 40px; left: 80px; color: rgba(255, 255, 255, 0.8); font-size: 18px; font-family: sans-serif;">
南昌大学计算机系 黎鹰
</div>

<!--
（背景音乐，微调音量）
大家好，欢迎回到我们的课程《AI赋能软件开发》。我是南昌大学的黎鹰。
我们进入模块二的第7节课。在之前的课程中，我们已经为游戏世界赋予了规则，角色终于可以按我们的指令移动了。但它还缺少一样至关重要的东西——“心跳”。
我们这节课的核心任务，就是学习如何为我们的游戏世界，赋予一颗永不停歇的心脏，驱动它持续运转，真正地“活”起来。
让我们开始吧！
-->

---

## **回顾：一次性的世界**

<div class="columns ratio-6-4">
<div style="font-size: 0.9em;">

在上一节课，我们取得了巨大的进步！

我们为游戏世界建立了“规则”，玩家终于可以输入指令，并从一个地点移动到另一个地点。

但是，我们的世界还有一个致命的问题：**它没有“心跳”**。

程序在执行完一次指令后，就立刻**结束**了。玩家每想做一件事，都必须重新运行一次程序。

这显然不是一个“游戏”，它只是一次性的“问答”。

**我们如何让游戏世界“活”起来，能够持续不断地接收玩家的指令，永远运转下去？**

</div>
<div class="align-middle-center">

![一个心脏停止跳动的静态心电图 width:400px](../../../lectures/images/2025-11-13-20-35-54.png)

</div>
</div>

<!--
我们先来回顾一下。在上一节课，我们取得了巨大的进步，对吧？我们的角色终于可以在我们设计的地图里，通过指令从一个地点移动到另一个地点了。
但是，大家在测试的时候，肯定也发现了一个很别扭的问题。那就是，程序在执行完一次指令之后，就立刻退出了。如果你想去下一个地方，或者想看看地点里有什么，就必须重新运行一次程序。
这就像一个只会说一句话就挂断的电话，完全无法持续交流。
这显然不是一个真正的“游戏”，它只是一个一次性的问答机器。那么，我们这节课核心要解决的问题就是：如何让这个世界“活”起来，让它拥有自己的心跳，能够不知疲倦地、永远地运转下去，持续接收我们的指令呢？
-->

---

## **问题的本质：一次性执行流程**

<div class="columns ratio-6-4">
<div style="font-size: 0.88em;">

要回答上一页的问题，首先需要理解当前程序的**执行流程**。它是一种“**一次性**”的顺序流程：从头执行到尾，然后结束。

而所有交互式应用的灵魂，都是一个“**永动机**”式的核心引擎。它的流程是**循环的**：
> **等待输入 -> 处理输入 -> 更新状态 -> 显示结果 -> 回到等待...**

为了实现从“一次性”到“**可重复**”的飞跃，程序语言提供了一种强大的结构，它能让一段代码根据我们的需要，**重复执行一次、多次、甚至无限次**。

这个强大的结构，就是我们这节课要学习的——**循环 (Loop)**。

</div>
<div class="align-middle-center">

![一个直线箭头和一个循环箭头，对比两种流程 width:400px](../../../lectures/images/2025-11-13-21-08-07.png)

</div>
</div>

<!--
好，刚刚我们提出了问题，那这个问题的本质是什么呢？（稍作停顿）
问题的本质，在于我们程序当前的“执行流程”。它是一种“一次性”的、或者说线性的流程，就像一条单行道，从头开到尾，就结束了。
但所有大家平时玩的、用的交互式应用，比如游戏、网站、甚至是手机操作系统，它们的灵魂，都不是一条单行道，而是一个“永动机”式的核心引擎。
它的流程是循环的：永远在‘等待你的输入 -> 处理你的输入 -> 显示结果’，然后关键的一步，是它会‘回到等待’，而不是结束。
为了实现我们程序从‘一次性’到‘可重复’的这个关键飞跃，编程语言为我们提供了一种极其强大的结构，这个结构，就是我们这节课要学习的主角——循环，Loop。
-->

---

## **本节课目标：掌握构建“游戏引擎”的咒语**

<div class="columns ratio-6-4">
<div style="font-size: 0.85em;">

在本节课，我们将学习指挥AI使用编程中最强大的“**重复咒语**”：**循环 (Loop)**。

**你的新能力：**
1.  **定义“重复规则”**
    - 学会用“对于列表中的每一项...”或“当条件为真时，永远...”的结构，向AI清晰地描述重复性任务。
2.  **审查“核心引擎”**
    - 审查AI代码中的循环结构，确保游戏的核心流程正确无误。

**最终产出：**
- 一个拥有“心跳”的、可以持续运行的“**迷你武侠游戏引擎**”。

</div>
<div class="align-middle-center">

![一个魔法师念出咒语，一个巨大的齿轮开始缓缓转动 width:400px](../../../lectures/images/2025-11-13-21-15-57.png)

</div>
</div>

<!--
明确了问题和解决方案，我们这节课的目标也就非常清晰了。
这节课，我们将要学会指挥AI使用编程中最强大的‘重复咒语’——也就是循环。
课程结束时，大家会获得两项新能力：
第一，是学会如何向AI下达‘重复执行’的指令，比如‘请挨个处理这些物品’，或者‘只要游戏没结束，就一直运行’。
第二，是获得审查AI生成的循环代码的能力，确保我们游戏的核心引擎是按照我们的设计意图来运转的。
最终，我们将合力创造出一个拥有‘心跳’的、可以持续运行的‘迷你武侠游戏引擎’。这是我们这节课最终的产出。
-->

---

## **循环的两种形态**

在Python中，循环主要有两种形态，分别应对不同的“重复”场景。

<div class="columns" style="font-size: 0.88em;">
<div>

### **`for` 循环 (遍历循环)**
- **核心思想**：**“挨个处理一遍”**。
- **适用场景**：处理一个已知“**集合**”（如列表、字典）中的每一个元素。
- **现实类比**：图书馆员为一箱书里的**每一本书**盖章。
- **游戏应用**：
  - 打印出玩家背包里的**每一件物品**。
  - 检查一个地点里**每一个NPC**的状态。

</div>
<div>

### **`while` 循环 (条件循环)**
- **核心思想**：**“只要条件满足，就一直做”**。
- **适用场景**：在某个条件为真时，**无限次**地重复执行某项任务。
- **现实类比**：**只要**汽车还有油，就一直往前开。
- **游戏应用**：
  - **只要**玩家还没死，游戏就一直运行。
  - **只要**Boss还没被击败，就继续战斗。

</div>
</div>

**这节课，我们将先用`for`循环理解“遍历”的奥秘，再用`while`循环为我们的游戏装上“心跳”。**

<!--
好，那循环这个‘重复咒语’具体要怎么念呢？在Python里，它主要有两种形态，分别应对不同的重复场景。
第一种，叫做`for`循环，你也可以叫它‘遍历循环’。它的核心思想非常简单，就是‘挨个处理一遍’。什么时候用呢？当你有一个已知数量的集合，比如一个装满物品的列表，你想对里面的每一个物品都做同样的操作时，就用`for`循环。就像图书馆管理员，要给一整箱书里的每一本书盖章，这个重复动作就是`for`循环的典型应用。
第二种，叫做`while`循环，或者叫‘条件循环’。它的思想更霸道，是‘只要条件满足，就一直做’。它处理的不是一个已知的集合，而是一个未知的、可能无限的重复场景。只要某个条件为真，它就会永远执行下去。就像开车，只要你还有油，你就可以一直往前开。在游戏里，‘只要玩家没死，游戏就一直运行’，这就是`while`循环的精髓。
这节课，我们会先学习`for`循环，然后用更强大的`while`循环，为我们的游戏装上心跳。
-->

---

## **升级蓝图：用`列表(List)`丰富世界**

<div style="font-size: 0.85em;">

我们的世界地图已经有了地点和出口，但空间里什么东西也没有。如何为地点添加多个物品或NPC呢？

这时，我们需要一种新的“数据盒子”：**列表 (List)**。

- **它是什么**：一个“**有序的货架**”，可以按顺序存放**一排**物品。
- **它与字典的区别**：字典通过“名字” (`key`) 来查找东西，而列表通过“位置” (`index`) 来查找。
- **写法**：用方括号 `[]` 包裹，物品间用逗号 `,` 分隔。

**让我们立即升级“扬州广场”的蓝图：**
```python
world = {
    'guangchang': {
        'description': '这里是扬州广场，人来人往。',
        'exits': {'east': 'chaguan'},
        'items': ['一柄生锈的铁剑', '一个啃过的苹果'] # 新增！
    },
    'chaguan': {
        # ...
    }
}
```
</div>

<!--
在正式学习`for`循环之前，我们先要对我们的世界蓝图做一次小小的升级。
大家看，我们现在的世界地图，虽然有了地点和出口，但是每个地点里面都是空空如也的，什么东西都没有。如果我们想在一个地点里放上好几件物品，或者好几个NPC，应该怎么办呢？
这就需要一种新的‘数据盒子’，它就是‘列表’，英文是 List。
你可以把它想象成一个‘有序的货架’，可以一格一格地，按顺序存放一排物品。
它和我们之前学的字典有什么区别呢？很简单，字典是通过‘名字’，也就是key来找东西，而列表是通过‘位置’，也就是我们说的‘索引’来找。
它的写法也很简单，就是用一个方括号`[]`把所有东西包起来，中间用逗号隔开。
好，我们马上就用它来升级一下‘扬州广场’的蓝图，在里面加上一个新的`items`属性，里面放着一个列表，列表里有两样东西：‘一柄生锈的铁剑’和‘一个啃过的苹果’。
-->

---

## **`for`循环：自动化流水线**

有了“货架”（列表），我们如何才能方便地把货架上所有的东西都展示出来呢？

这就是`for`循环大显身手的时刻。它就像一条“**自动化流水线**”，能自动地“**挨个处理**”列表中的每一项。

<div class="columns ratio-6-4">
<div>

```python
# 1. 准备“传送带”上的“原料”
items_in_room = ['一柄生锈的铁剑', '一个啃过的苹果']

# 2. 搭建流水线，告诉它去处理 items_in_room 这个列表
for item in items_in_room:

    # 3. 设计“机械臂”的动作 (所有缩进的代码)
    #    对每一个传送过来的 item，都执行一次打印
    print(f"你发现地上有: {item}")
```

**`for`循环完美地解决了“遍历集合”这一核心需求。**

</div>
<div class="align-top-center">

![width:240px](../../../lectures/images/2025-11-13-20-46-14.png)

</div>
</div>

<!--
好，现在我们的地点里有了一个装满物品的‘货架’——也就是列表，那我们怎么才能方便地把这个货架上所有的东西都拿出来，展示给玩家看呢？总不能一个一个地手动去取吧？
当然不用！这正是`for`循环大显身手的时刻。`for`循环就像一条‘自动化流水线’，它能自动地‘挨个处理’列表里的每一项。
我们来看这个例子。第一步，我们准备好了‘原料’，就是一个包含两件物品的列表。
第二步，我们搭建流水线，看这句语法：`for item in items_in_room:`，它的意思就是：‘对于`items_in_room`这个列表里的**每一项**，我都把它取出来，临时取个名字叫`item`，然后送到流水线下面去处理’。
第三步，就是设计流水线‘机械臂’的动作，也就是所有这些缩进的代码。在这里，我们的动作很简单，就是打印一句话，告诉玩家‘你发现地上有’我们刚刚从流水线上拿到的这个`item`。
这样一来，无论列表里有多少东西，`for`循环都会自动地、不厌其烦地为我们处理完每一项。这个‘遍历集合’的需求，被`for`循环完美地解决了。
-->

---

## **架构师笔记：Python的“缩进”美学**

<div class="columns ratio-6-4">
<div style="font-size: 0.75em;">

大家可能已经注意到了，在`for`循环和`if`语句中，下面的代码块都向右缩进了一块。

在Python中，**缩进不仅仅是为了好看，它就是语法的一部分！**

**缩进，定义了代码的“管辖范围”或“层级关系”。**
<div style="font-size: 0.6em;">

```python
# 这行代码在循环“外面”
print("循环即将开始...")

for item in a_list:
    # 这行代码在循环“里面”
    # 它属于 for 循环“管辖”
    print(f"处理: {item}")

# 这行代码也在循环“外面”
print("循环已结束。")
```
</div>

**核心规则**：所有归属于同一个代码块（如`if`块、`for`块）的语句，**必须**具有完全相同的缩进量。

这就像写文章时，用段落来组织思想一样。AI助理通常能完美处理，但作为“架构师”，我们必须能看懂这层关系。

</div>
<div class="align-middle-center">

![一个文件夹包含多个文件的图标，形象地表示层级关系 width:400px](../../../lectures/images/2025-11-13-21-23-40.png)

</div>
</div>

<!--
在继续学习`while`循环之前，我们必须先停下来，讨论一个Python语言非常独特、也极其重要的特性——那就是‘缩进’。
大家可能已经注意到了，在`if`语句和我们刚刚学的`for`循环里，下面的代码块都会向右缩进一块。
在很多其他编程语言里，缩进主要是为了代码好看，但在Python里，它远不止如此——**缩进，就是语法的一部分！**
它的作用，是用来定义代码的‘管辖范围’或者说‘层级关系’。
我们看这个例子，第一行代码，没有缩进，它在循环的‘外面’。`for`循环这一行也没有。但是，`for`循环下面这行`print`，它缩进了，这就意味着，它在循环的‘里面’，它归`for`循环‘管辖’，是`for`循环要重复执行的主体。
而当缩进结束，最后一行`print`又回到原来的位置，它就又跑到了循环的‘外面’。
所以，核心规则就是：所有归属于同一个代码块的语句，比如一个`for`循环要执行的所有指令，它们必须具有完全相同的缩进量。
这就像我们写文章用段落来组织思想一样，是Python组织代码逻辑的方式。AI助理通常能帮我们完美地处理好缩进，但作为‘架构师’，我们必须能看懂这层重要的关系。
-->

---

## **`while`循环：游戏世界的“心跳”**

<div class="columns ratio-6-4">
<div style="font-size: 0.85em;">

理解了`for`循环，我们来看`while`循环。它更简单，也更“霸道”。

它就像游戏世界的“**心跳**”或“**主引擎**”。

```python
while True:
    # 只要宇宙不毁灭 (True永远是True)
    # 就永远、不知疲倦地
    # 重复执行这里的所有代码
    
    print("游戏世界的心跳...咚...")
    # (为了避免无限打印刷屏，我们让它暂停一下)
    import time
    time.sleep(1)
```

`while True:` 创建了一个**无限循环**。这正是所有交互式应用（游戏、App、操作系统）的底层模型：它们都运行在一个巨大的、永不停止的`while`循环中，时刻等待着用户的操作。

</div>
<div class="align-middle-center" style="flex-direction: column; justify-content: space-around; height: 100%;">
<div>

![一个不断搏动的心脏，或者一个永恒运转的引擎 width:200px](../../../lectures/images/2025-11-13-21-27-44.png)

</div>
<div>

![width:200px](../../../lectures/images/2025-11-13-22-29-02.png)

</div>
</div>
</div>

<!--
理解了`for`循环和缩进之后，我们终于可以请出这节课另一个主角——`while`循环了。它更简单，也更‘霸道’。
如果说`for`循环是处理有限任务的流水线，那`while`循环，就是我们游戏世界真正的‘心跳’和‘主引擎’。
我们来看这个最经典、最强大的结构：`while True:`。它的意思是，‘当条件为True（真）的时候，就执行下面的代码’。而`True`这个值，它永远是真，就好像宇宙不毁灭，它就永远成立。
所以，`while True:`创建的就是一个‘无限循环’。它会永远、不知疲倦地重复执行缩进里的所有代码。
大家看，我们这里让它每一秒钟打印一次‘游戏世界的心跳...咚...’，它就会永远这么执行下去。
这，正是所有交互式应用，比如游戏、App、甚至我们电脑的操作系统，它们最底层的运行模型。它们都运行在一个巨大的、永不停止的`while`循环里，时刻等待着我们用户的下一个操作。
-->

---

## **`break`：紧急制动，跳出循环**
<div style="font-size: 0.85em;">

一个无限循环的引擎，必须有一个“**熄火**”的开关，否则它将永不停止，直到程序被强制关闭。

在`while`循环中，`break`语句就是这个“**紧急制动**”开关。

当程序在循环中执行到`break`时，它会**立刻、无条件地**跳出当前所在的循环，继续执行循环后面的代码。

```python
while True:
    command = input("请输入指令 (输入/quit退出): ")
    
    if command == "/quit":
        print("你决定退出江湖...")
        break # 条件满足，执行“紧急制动”，跳出while循环
    
    print(f"你输入了: {command}")

# break后，程序会跳转到这里继续执行
print("游戏已结束。")
```

**`if` 和 `break` 的组合，是控制 `while` 循环何时结束的标准模式。**
</div>

<!--
一个永不停止的引擎听起来很棒，但如果它没有‘熄火’的开关，那就会成为一场灾难。程序会一直运行，直到被我们强制关闭。
所以，我们必须为这个无限循环的引擎，配备一个‘紧急制动’的开关。在`while`循环中，这个开关就是`break`语句。
它的作用非常简单粗暴：当程序在循环中执行到`break`这个词的时候，它会立刻、无条件地跳出当前所在的这层循环，去执行循环外面的代码。
我们来看这个例子，在一个`while True`循环里，我们首先等待用户输入指令。然后用一个`if`语句来判断，如果用户输入的指令等于字符串`'/quit'`，那么我们就打印一句话，然后执行`break`。
一旦`break`被执行，程序就会立刻跳出`while`循环，执行循环下面的代码，也就是打印‘游戏已结束’。
所以，`if`判断加上`break`语句，就是我们控制`while True`这种无限循环何时结束的标准模式，大家要牢牢记住这个组合。
-->

---

## **思考题：另一种“熄火”方式**
<div style="font-size: 0.7em;">

我们刚刚学会了用 `break` 语句作为循环的“紧急制动”。

**那么，有没有办法不使用 `break`，也能让 `while` 循环在特定条件下优雅地停止呢？**

**答案：改变循环自身的“条件”**

回想一下 `while` 循环的核心思想：**只要条件满足，就一直做**。

`while True:` 的条件永远为真，所以我们才需要 `break` 来强行跳出。但如果我们不让条件永远为真，而是用一个“开关”变量来控制呢？

```python
# 1. 设置一个“开关”变量，初始状态为“开”
game_is_running = True

# 2. 循环的持续，依赖于这个“开关”的状态
while game_is_running:
    command = input("> ")
    if command == "/quit":
        # 3. 当满足退出条件时，我们只需关掉“开关”
        print("你决定退出江湖...")
        game_is_running = False

# 4. 开关关闭后，循环在下一次检查条件时，就会自然结束
print("游戏已结束。")
```
这种使用一个变量来控制循环是否继续的方式，我们称之为使用“**状态变量**”。

</div>

<!--
好，我们刚刚学会了用`break`作为紧急制动。现在，我想请大家开动脑筋，思考一个问题：有没有办法不使用`break`，也能让我们的`while`循环在特定条件下停下来呢？
（稍作停顿，给学生思考时间）
... 答案是有的。关键在于，我们要改变循环自身的‘条件’。
大家回想一下`while`循环的本质：‘只要条件满足，就一直做’。`while True`之所以需要`break`，就是因为它的条件‘永远满足’。
那如果我们不让它永远满足呢？比如说，我们用一个‘开关’变量来控制。
看这个例子，我们先定义一个变量`game_is_running`，把它设为`True`，这代表我们的‘游戏开关’是打开的。然后，我们的`while`循环就依赖于这个‘开关’的状态：`while game_is_running:`。
在循环里面，当用户输入`/quit`时，我们做的事情不再是`break`，而是把这个‘开关’关掉，也就是把`game_is_running`这个变量的值改成`False`。
这样一来，当这一轮循环结束后，下一次`while`再去检查它的条件时，发现`game_is_running`不再是`True`了，于是，循环就非常‘自然’地结束了。
这种方法，我们通常称之为使用‘状态变量’来控制循环。
-->

---

## **方案对比：“状态变量” vs `break`**

<div class="columns" style="font-size: 0.85em;">
<div>

### **方案一：使用“状态变量”**

```python
game_is_running = True
while game_is_running:
    command = input("> ")
    if command == "/quit":
        game_is_running = False

print("游戏已结束。")
```
- **核心**：通过改变循环自身的**条件**来结束循环。
- **优点**：循环的进入和退出条件由一个变量统一控制，逻辑更集中、更 **“优雅”** 。
- **适用**：当循环的持续与否，能明确对应到一个“状态”时（如 `游戏运行中` / `连接已建立`）。

</div>
<div>

### **方案二：使用 `break`**

```python
while True:
    command = input("> ")
    if command == "/quit":
        break 

print("游戏已结束。")
```
- **核心**：在循环体**内部**，通过一个“紧急出口”强行跳出。
- **优点**：意图非常明确，可以在循环体内部的**任何位置**（甚至深层嵌套的`if`里）立刻终止循环。
- **适用**：常用于游戏主循环、或处理需要立即退出的异常情况。

</div>
</div>

<!--
好，我们现在有了两种控制循环退出的方案，我们把它们并排放在一起，对比一下。
左边，是刚刚学的‘状态变量’方案。它的核心，是通过改变循环自身的条件来让它自然结束。
右边，是`break`方案，它的核心是在循环内部，通过一个‘紧急出口’强行跳出。
哪种更好呢？其实没有绝对的好坏，它们各有优劣和适用的场景。
‘状态变量’方案的优点是，循环的启停条件都由这一个变量统一控制，逻辑上非常集中和清晰，代码读起来也更‘优雅’。当你的循环是否要继续，能明确地对应到一个‘状态’时，比如‘游戏是否运行中’，或者‘网络是否已连接’，用它就特别合适。
而`break`方案的优点是，它的意图非常明确，就是‘立刻停止，马上出去’，而且它可以在循环体内部的任何地方，哪怕是藏在很深的`if`判断里，都能立刻终止整个循环。所以它经常被用在像游戏主循环这种需要一个‘总开关’的地方，或者处理一些需要立即退出的异常情况。
在我们的游戏中，这两种方法都可以，但`while True`加`break`是更常见的一种实践。
-->

---

## **你的新角色：“游戏引擎工程师”**

<div class="columns ratio-6-4">
<div style="font-size: 0.8em;">

祝贺你！掌握了循环，你的角色也因此迎来了重要的**转变**！

你不再是那个只能设计静态地图的“**建筑师**”，而是**转变**为能让整个世界“**活**”过来、运转起来的“**游戏引擎工程师**”。

**你的核心价值，不再是“定义事物”，而是“定义流程”**：
- **你负责**：设计游戏世界的核心“**心跳流程**”（`while`循环内的逻辑）。
- **计算机负责**：扮演拥有绝对“**耐心**”的“世界引擎”，为你完美地、永不疲倦地维持世界的运转。

这就是“**交互式应用**”的本质，也是编程能创造出“活的”世界的关键。

</div>
<div class="align-middle-center">

![一个意气风发的工程师，站在控制台前，指挥着一个巨大的、充满活力的游戏引擎 width:400px](../../../lectures/images/2025-11-13-21-34-38.png)

</div>
</div>

<!--
祝贺大家！在掌握了循环这个强大的工具之后，你们的角色也因此迎来了又一次重要的转变！
你们不再仅仅是那个只能设计静态地图的‘建筑师’，而是转变为能让整个世界‘活’过来、运转起来的‘游戏引擎工程师’。
大家要理解，你们的核心价值，也随之发生了变化。不再仅仅是‘定义事物’——比如一个地点长什么样；而是要去‘定义流程’——比如，游戏的心跳流程应该是什么样的，玩家的指令应该如何被循环处理。
你负责设计这个核心流程，而计算机，则扮演那个拥有绝对‘耐心’的世界引擎，为你完美地、永不疲倦地维持这个世界的运转。
这，就是‘交互式应用’的本质，也是编程能创造出‘活的’世界的关键所在。
-->

---

## **动手环节：为你的世界注入“心跳”**

<div class="columns ratio-6-4">
<div>

理论学习结束，现在，让我们以“游戏引擎工程师”的身份，为我们前两节课创造的“静态世界”注入生命！

**我们的任务：**
将前两节课的代码（世界定义、指令解析）整合起来，并用一个`while True`循环包裹住，让它成为一个可以持续运行的真正游戏！

</div>
<div class="align-middle-center">

![一个静态的、灰色的游戏世界，在一个巨大的“while”循环符号的注入下，变得色彩斑斓、充满活力 width:400px](../../../lectures/images/2025-11-13-21-57-19.png)

</div>
</div>

<!--
好了，理论学习到此为止。现在，让我们重新戴上‘游戏引擎工程师’的帽子，亲自动手，为我们前两节课创造的那个‘静态世界’，注入生命，赋予它一颗真正的心跳！
我们的任务很明确：把我们之前所有的代码，包括世界定义、指令解析等等，整合起来，然后用一个`while True`循环把它们包裹住，让它从一个一次性的问答程序，变成一个可以持续运行的、真正的游戏！
-->

---

## **动手环节(1/2)：下达指令**

请在VS Code中启动 `qwen` 助手，并向它下达你的“引擎设计图纸”：

> 请帮我重构之前的武侠游戏脚本，为其添加一个“游戏主循环”，并升级`look`指令的功能。
> 
> 具体要求如下：
> 1.  将我们之前定义好的 `world` 字典（请确保至少一个地点包含一个`items`列表）和 `player_location` 变量放在脚本的最上方。
> 2.  在这之后，添加一个 `while True:` 无限循环，将后续所有逻辑都包裹在内。
> 3.  在循环内部，当玩家输入 "/look" 指令时，除了打印地点描述，还需检查当前地点是否存在 `items` 列表。如果存在且列表不为空，则使用 **for循环** 遍历该列表，并打印出所有物品，例如“你还看到了：【物品名】”。
> 4.  确保当指令是 "/quit" 时，程序能够使用 `break` 语句正确地跳出循环。

<!--
好，请大家打开VS Code，启动我们的AI编程助手。然后，把我们接下来要下达的这份‘引擎设计图纸’，也就是这段Prompt，完整地复制给它。
我们来解读一下这个指令：我们要求它重构之前的脚本，添加一个‘游戏主循环’，并且升级`look`指令的功能。
具体要求有四点：
第一，把`world`字典和`player_location`变量放在最上面。
第二，用`while True:`无限循环，把后面的所有逻辑都包起来。
第三，当玩家输入`/look`时，除了显示描述，还要用`for`循环去遍历并打印`items`列表里的东西。
第四，确保输入`/quit`时，能用`break`跳出循环。
好，大家把这段指令发给AI，然后运行一下生成的代码，看看会发生什么。
-->

---

## **敏锐的观察：为何/look会重复描述？**

<div class="columns">
<div>

**出现“Bug”**

根据上一页的指令，**AI生成的代码逻辑**很可能会是这样：

```python
# 游戏主循环
while True:
    # 1. 无条件打印当前地点描述
    print(world[player_location]['description'])

    # 2. 获取并处理指令
    command = input("> ")
    if command == "/look":
        # 3. /look指令又打印了一次描述
        print(world[player_location]['description'])
    # ... 其他指令
```

</div>
<div>

**问题分析**

我们设计的“游戏主循环”过于简单，它在**每次循环开始**时，都会无条件地打印一遍描述，而`/look`指令的逻辑又会**再打印一次**，因此造成了重复。

这个问题，我们将在下一步解决。

</div>
</div>

<!--
好了，相信大家运行完代码之后，已经发现了一些不对劲的地方。最明显的一个‘Bug’就是，当你输入`/look`的时候，是不是发现地点描述被打印了两次？（等待学生确认）
没错。为什么会这样呢？我们作为架构师，需要审查一下AI生成的代码。
根据我们上一页的指令，AI很自然地会生成这样的逻辑：它把我们之前‘先打印描述，再获取指令’的整个过程，一股脑地放进了`while`循环。
这就导致了，循环每开始一次，它就无条件地打印一次描述。然后，当我们输入`/look`时，`if`判断成立，它又执行了一次打印描述的逻辑。两次打印，Bug就是这么来的。
所以，问题的根源在于我们设计的‘游戏主循环’过于简单了。这个问题，我们下一步就来解决它。
-->

---

## **迭代一：修正“重复描述”问题**

<div class="columns">
<div>

**解决方案**

我们应该把“打印描述”这个动作，从“循环开始时无条件执行”，改为“**仅在必要时执行**”。

具体来说，只有在两种情况下才需要展示描述：
1.  玩家移动到一个**新**地点后。
2.  玩家主动输入 `/look` 指令时。

</div>
<div>

**迭代指令 (Prompt 1)**

> 请重构代码，解决/look重复描述的问题：
> 1. 删除`while`循环开头无条件打印地点描述的代码。
> 2. 在`while`循环**之前**，打印一次初始位置的描述，作为开场白。
> 3. 修改`/go`指令的逻辑：当玩家移动成功后，**必须**打印新地点的描述。

</div>
</div>

<!--
分析清楚了问题，我们就可以提出解决方案了。很简单，我们应该把‘打印描述’这个动作，从‘循环开始时无条件执行’，改为‘仅在必要时执行’。
那什么时候是‘必要时’呢？主要就是两种情况：第一，是玩家刚刚移动到一个新的地点之后，他需要知道新地点长什么样。第二，就是玩家主动输入`/look`指令，想重新看看当前地点时。
明确了解决方案，我们就可以给AI下达更精确的迭代指令了。大家看右边，这是我们的第一份迭代指令。
我们告诉AI：第一，删除循环开头那句无条件打印描述的代码。第二，为了让玩家一进游戏就能看到初始场景，我们让它在循环开始前，先打印一次，作为开场白。第三，也是最关键的，修改`/go`指令的逻辑，当玩家移动成功后，必须打印新地点的描述。
好，现在请大家把这份新的迭代指令发给AI，看看它能不能帮我们修复这个Bug。
-->

---

## **新的改进：如何为玩家“指路”？**

<div class="columns">
<div>

**当前体验的缺陷**

当玩家输入`/look`时，他只能看到当前场景的描述，却不知道接下来能去哪里。

> 你来到了扬州广场，人来人往。
>
> **(然后呢？我能去哪儿？)**

这就像在一个没有路牌的城市里探索，体验很差。

</div>
<div style="font-size: 0.77em;">

**功能升级思路**

我们可以在`/look`指令的功能里，增加“显示出口”的逻辑。

1.  在打印完地点描述后，获取当前地点的`exits`字典。
2.  遍历这个字典，将所有出口信息格式化并展示给玩家。
    - **思考一下：** 这里要“挨个处理”一个已知的集合（字典），我们应该使用 `for` 循环还是 `while` 循环呢？

**期望效果：**
> 你来到了扬州广场，人来人往。
>
> **此地出口：** east(茶馆)

这样，玩家就能根据提示，愉快地探索世界了。

</div>
</div>

<!--
好，第一个Bug解决了。但大家在玩的时候，可能又发现了第二个体验上的缺陷。
那就是，当你输入`/look`的时候，虽然能看到地点描述了，但你还是不知道这个地方有哪些出口，不知道下一步能去哪儿。
就像这个例子，你到了扬州广场，然后呢？能去东边还是西边？完全不知道。这就像在一个没有路牌的城市里开车，体验非常差。
这个问题，其实不是Bug，而是一个‘缺失的功能’。我们作为设计师，一开始就没想到要给玩家指路。
那解决方案也很明确，我们只需要升级`/look`指令的功能，在它打印完描述之后，再把当前地点的出口信息也一并展示给玩家。
比如，我们期望看到这样的效果：‘此地出口：east(茶馆)’。这样，玩家就能根据提示，愉快地探索我们的世界了。
现在，大家可以思考一下，要实现这个‘遍历字典并打印’的功能，我们应该用`for`循环还是`while`循环呢？
-->

---

## **迭代二：为/look指令增加“指路”功能**

<div class="columns">
<div>

**解决方案**

我们已经分析过，解决方案是在执行`/look`指令时，增加显示出口的逻辑。

这需要我们：
1. 获取当前地点的`exits`字典。
2. 遍历字典，并格式化输出。

</div>
<div>

**迭代指令 (Prompt 2)**

> 功能升级——请在现有代码基础上，增强/look指令：
> 1. 当执行`/look`指令时，在打印完地点描述和物品后，请增加一个新功能：
> 2. 检查并打印当前所有可用的出口，例如：“此地出口：east(茶馆)”。

</div>
</div>

<!--
好，刚刚的问题，相信大家心里已经有了答案。要‘挨个处理’一个已知的集合，我们当然是用`for`循环。
所以，解决方案非常直接，就是在执行`/look`指令时，增加一个遍历`exits`字典的`for`循环。
我们看右边，这就是我们第二次迭代的指令。非常简单，就一句话：‘功能升级！请在现有代码基础上，增强/look指令’。
具体做什么呢？就是在打印完地点描述和物品后，增加一个新功能：检查并打印当前所有可用的出口。
我们把这个指令发给AI，它就会自动地在原有的`/look`逻辑后面，为我们加上一个遍历并打印出口的`for`循环。大家动手试一下，看看我们的世界是不是变得更完美了。
-->

---

## **回顾：我们的第一次“迭代循环”**

<div class="columns">
<div class="align-middle-center">

**过程模型：迭代开发**

![width:200](../../../lectures/images/2025-11-13-22-30-16.png)

</div>
<div>

**总结与展望**

祝贺你！你刚刚完整地体验了一次软件开发中最核心的“**迭代开发**”循环。

我们没有追求一次性写出“完美”的程序，而是在一个可用的基础上，通过“运行-反馈-修改”的循环，让程序的功能和体验逐步完善。

这种迭代思想，是应对复杂问题的关键。在**模块三**，我们将学习“函数”、调试技巧和高效协作策略，从**代码、问题、指令**三个维度，全面提升我们的迭代开发能力。

</div>
</div>

<!--
好了，各位同学，祝贺你们！我们刚刚不知不觉地，已经完整地体验了一次软件开发中最核心、最真实的‘迭代开发’循环。
我们来看左边的这个模型，这正是我们刚刚所做的：我们先运行了第一版代码，然后发现了Bug和新的需求。接着，我们分析了问题产生的原因，并提出了解决方案。再然后，我们把解决方案变成了清晰的指令，指挥AI去迭代我们的代码。最后，我们运行新代码，又回到了起点，去发现新的问题...
这个‘运行-反馈-修改’的循环，就是软件开发的本质。
我们没有追求一次性就写出‘完美’的程序，因为那几乎不可能。我们做的，是在一个可用的基础上，通过一轮一轮的迭代，让程序的功能和体验逐步完善。
这种迭代思想，是所有工程师应对复杂问题的关键。在接下来的模块三，我们将学习‘函数’、调试技巧和高效协作策略，从代码、问题、指令这三个维度，全面提升我们在这个迭代循环中的能力，让人机协作开发真正进入快车道。
-->

---

## **本节总结：我们获得了什么？**

<div class="columns ratio-6-4">
<div style="font-size: 0.82em;">

在本节课，我们掌握了编程世界最强大的“发动机”——循环。

- **一个核心认知**
  - “循环”是解决“重复性”问题的终极武器，是实现自动化和交互式应用的基石。

- **两种核心句式**
  - 掌握了 `for item in a_list:` (遍历) 和 `while True:` (永动) 这两种自动化流程的“咒语”。

- **一种新能力**
  - 获得了构建“持续运行”的交互式应用的能力，你的关注点也从高层的“蓝图设计”，**深入到了驱动世界运转的“底层引擎”**。

</div>
<div class="align-middle-center">

![一个宝箱，里面装着齿轮(代表自动化)、列表和循环的图标 width:400px](../../../lectures/images/2025-11-13-22-08-27.png)

</div>
</div>

<!--
好了，在结束这节课的课程之前，我们快速总结一下。
在本节课，我们掌握了编程世界最强大的‘发动机’——循环。
首先，我们建立了一个核心认知：‘循环’是解决所有‘重复性’问题的终极武器，也是所有交互式应用之所以能‘活’起来的基石。
其次，我们掌握了两种核心的‘重复咒语’：一个是用于‘挨个处理’已知集合的`for item in a_list:`；另一个是用于构建‘永动机’的`while True:`。
最重要的是，我们获得了一种全新的能力，那就是构建一个可以‘持续运行’的应用。我们的关注点，也从之前高层的‘蓝图设计’，成功地深入到了驱动世界运转的‘底层引擎’。大家已经真正成为一名‘游戏引擎工程师’了。
-->

---

## **下一步预告：模块收官项目**

<div class="columns ratio-6-4">
<div style="font-size: 0.9em;">

**祝贺你！至此，你已经学完了编程世界最核心的“三原色”：**

- **变量 (Variables)**：让世界有了“**地图**”和“**状态**”。
- **条件 (Conditions)**：让世界有了“**规则**”和“**选择**”。
- **循环 (Loops)**：让世界有了“**心跳**”和“**时间**”。

在模块二的最后一节课，我们将不再学习新语法，而是把这“三原色”调和在一起，以“游戏设计师”的身份，为我们的武侠世界**增加更多的细节和创意**，完成我们模块的收官项目！

</div>
<div class="align-middle-center">

![一个调色盘，红黄蓝三原色混合在一起，创造出五彩斑斓的色彩 width:400px](../../../lectures/images/2025-11-13-22-17-02.png)

</div>
</div>

<!--
祝贺大家！到这节课为止，你们已经学完了编程世界最核心的‘三原色’：
变量，让我们的世界有了‘地图’和‘状态’；
条件判断，让世界有了‘规则’和‘选择’；
以及这节课学的循环，让世界有了‘心跳’和‘时间’。
在下一节课，我们将不再学习任何新的语法了。我们将把这‘三原色’调和在一起，真正以‘游戏设计师’的身份，为我们的武侠世界增加更多的细节和创意，完成我们模块二的收官项目！请大家保持期待！
-->