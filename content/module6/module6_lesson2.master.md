---
marp: true
theme: default
paginate: true
size: 16:9
math: katex
---

<style>
/* --- 布局辅助样式 --- */
.columns {
  display: grid;
  grid-template-columns: repeat(2, minmax(0, 1fr));
  gap: 1rem;
}
.columns pre code {
  white-space: pre-wrap !important;
  overflow-wrap: break-word !important;
}
/* --- 列表缩进样式修正 --- */
ul, ol {
  padding-inline-start: 25px; /* 减小列表的左侧缩进 */
}
.columns.ratio-4-6 { grid-template-columns: 4fr 6fr; }
.columns.ratio-6-4 { grid-template-columns: 6fr 4fr; }
.columns.ratio-3-7 { grid-template-columns: 3fr 7fr; }
.columns.ratio-7-3 { grid-template-columns: 7fr 3fr; }
.align-top    { display: flex; align-items: flex-start; }
.align-middle { display: flex; align-items: center; }
.align-bottom { display: flex; align-items: flex-end; }
.align-left   { display: flex; justify-content: flex-start; }
.align-center { display: flex; justify-content: center; }
.align-right  { display: flex; justify-content: flex-end; }
.align-top-left     { display: flex; justify-content: flex-start; align-items: flex-start; }
.align-top-center   { display: flex; justify-content: center;  align-items: flex-start; }
.align-top-right    { display: flex; justify-content: flex-end;   align-items: flex-start; }
.align-middle-left  { display: flex; justify-content: flex-start; align-items: center; }
.align-middle-center{ display: flex; justify-content: center;  align-items: center; }
.align-middle-right { display: flex; justify-content: flex-end;   align-items: center; }
.align-bottom-left  { display: flex; justify-content: flex-start; align-items: flex-end; }
.align-bottom-center{ display: flex; justify-content: center;  align-items: flex-end; }
.align-bottom-right { display: flex; justify-content: flex-end;   align-items: flex-end; }
.tip {
  background-color: #f0f8ff;
  border-left: 5px solid #1e90ff;
  padding: 15px;
}
.insight {
  background-color: #eefcff; 
  border-left: 5px solid #17a2b8; 
  padding: 15px; 
}
.key-point {
  background-color: #fffbe6; 
  border-left: 5px solid #ffc107; 
  padding: 15px; 
}
.tip p, .tip li,
.insight p, .insight li,
.key-point p, .key-point li {
  font-size: inherit !important;
}
.styled-div p, 
.styled-div li, 
.styled-div ol, 
.styled-div ul, 
.styled-div blockquote {
  font-size: inherit !important;
}
</style>

![bg blur:1px brightness:60%](image/2025-12-13-14-53-06.png)

<style scoped>
h1{
  color: #F5F5F5;
  text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.8);
}
h2 {
  color: #E0E0E0;
  text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.8);
}
.course-title {
  position: absolute;
  top: 60px;
  left: 80px;
  background-color: rgba(0, 0, 0, 0.4);
  color: #fff;
  padding: 8px 15px;
  border-radius: 5px;
  font-size: 22px;
  font-weight: bold;
  letter-spacing: 1px;
  border-left: 5px solid #4CAF50;
}
</style>

<div class="course-title">AI赋能软件开发</div>

# 模块六: Python+Web开发入门
## 第22节课: 不仅是网页——前端交互基础

<div style="position: absolute; bottom: 40px; left: 80px; color: rgba(255, 255, 255, 0.8); font-size: 18px; font-family: sans-serif;">
南昌大学计算机系 黎鹰
</div>

<!--
- **类型**: 逐字稿
- **内容**: |
  (1分钟) 各位老师好！在上节课，我们成功搭建了“后厨”（API），并且用 Swagger 这个“试菜台”验证了它能工作。
  但是，我们不可能让学生或者用户去用 Swagger 点菜吧？那太不安全了。
  我们需要一个真正的“前厅”，一个装修精美、操作简单的网页。
  在模块一，我们用 AI 生成过漂亮的网页。今天，我们要更进一步：
  我们要让这个网页“活”起来，让它能真正连接到我们的 Python 后厨，实现数据的实时交互。
-->

<!--
- **类型**: 教学设计
- **内容**: |
  ### 教学时间: 2分钟
  ### 环节: 导入 (Introduction)
  **复习**: 快速回顾 Lesson 1 的内容 (API)，引出 Lesson 2 的主题 (Frontend)。
-->

<!--
- **类型**: 解释
- **内容**: |
  ### 什么是“交互”？
  这是从“看内容”到“用工具”的跨越。
  
  以前的静态网页像是一个**布告栏**，用户只能被动阅读。
  现在的 Web 应用像是一个**服务柜台**，用户可以操作（点击、输入），并得到即时的反馈（数据更新）。
  
  本节课的核心，就是要教会浏览器如何向服务器“发起业务申请”。
-->

---

## **1. 本课学习目标**

<div class="columns">
<div>

1.  **前后端分离**: 理解现代 Web 开发的核心模式。
2.  **让网页说话**: 使用 JavaScript 的 `fetch` 指令呼叫后厨。
3.  **Prompt 进阶**: 指挥 AI 写出既好看又能用的前端代码。

### **核心隐喻**
*   **HTML/CSS**: 餐厅装修 (静态)。
*   **JavaScript (Fetch)**: 服务员 (动态跑腿)。
*   **API**: 后厨窗口。

</div>
<div class="align-middle-center">

![配图：一个餐厅前厅，服务员在餐桌和后厨之间跑来跑去](image/2025-12-13-14-55-34.png)

</div>
</div>

<!--
- **类型**: 逐字稿
- **内容**: |
  (1分钟) 本节课有三个核心目标。
  第一，理解**“前后端分离”**。这就是现代 Web 开发的“厨房法则”：前厅点餐，后厨做菜。
  第二，掌握 **Fetch 指令**。这是我们的“传菜员”，负责在前后端之间传递数据。
  第三，进阶 **Prompt 技巧**。我们将学习如何指挥 AI 写出既好看又能用的前端代码。
  大家只要记住今天的核心隐喻：HTML/CSS 是装修，JS 是服务员，API 是后厨窗口。
-->

<!--
- **类型**: 教学设计
- **内容**: |
  ### 教学时间: 1分钟
  ### 环节: 目标 (Objective)
  **核心隐喻**: 贯穿全课的“餐厅隐喻”：Web页=前厅，API=后厨，JS=服务员。
  这有助于非技术背景学员理解抽象的“前后端分离”。
-->

<!--
- **类型**: 解释
- **内容**: |
  ### 为什么“好看”很重要？(User Experience)
  界面是建立信任的起点。在软件工程中，这被称为 **UX (用户体验)**。
  
  对于非技术背景的用户，一个粗糙简陋的界面往往意味着“不可靠”或“半成品”。
  让 AI 优化界面，不仅仅是为了美观，更是为了降低用户的**认知负荷**，让他们能直观地知道该点哪里。
-->

---

## **2. 认识能够“跑腿”的指令：Fetch**

<div class="columns ratio-4-6">
<div>

### **Fetch API**
浏览器内置的“传送门”。

**用法 (人话版)**:
1.  **去哪里**: `fetch('http://.../menu')`
2.  **拿什么**: `.then(拿到数据)`
3.  **做什么**: `.then(显示在屏幕上)`

</div>
<div>

```javascript
// JavaScript 代码片段
// 1. 呼叫后厨
fetch('http://127.0.0.1:8000/menu/红烧肉')
  // 2. 等待回话，并把回话转成文本(JSON)
  .then(response => response.json())
  // 3. 拿到结果，更新屏幕
  .then(data => {
      document.getElementById('price').innerText = data.price;
  });
```

</div>
</div>

<!--
- **类型**: 逐字稿
- **内容**: |
  (3分钟) 我们看一下这段前端的核心代码。这段 JS 代码其实就讲了一个故事：
  第一步 `fetch`：服务员跑去后厨窗口（URL）。
  第二步 `response.json`：服务员拿到厨师给的单子（JSON），看懂它。
  第三步 `innerText`：服务员跑回餐桌，把价格写在客人的账单上（更新网页元素）。
  这就是前后端交互的本质。我们不需要自己写这段代码，但我们要能看懂这个流程，才能指挥 AI 去写。
-->

<!--
- **类型**: 教学设计
- **内容**: |
  ### 教学时间: 3分钟
  ### 环节: 硬核知识 (Hard Core)
  **关键点**: Fetch 是本节课唯一的新技术点。
  用“人话”解释 Promise (.then)：不要讲异步原理，只讲“先去拿...拿到之后...再...”的顺序逻辑。
-->

<!--
- **类型**: 解释
- **内容**: |
  ### 为什么要有 .then (然后)？
  这涉及到一个关键概念：**异步 (Asynchronous)**。
  
  网络传输是需要时间的。就像在餐厅点完菜后，你不会傻站在柜台前不动，而是回座位做别的事（代码继续运行）。
  `.then()` 的机制就是告诉浏览器：“你先忙别的，等数据**端上来之后**，**再**回来执行这一步。”
  这保证了网页不会因为网络卡顿而“假死”。
-->

---

## **3. 案例背景：数字化餐厅的挑战**

<div class="columns">
<div>

### **老板的模糊需求 (Fuzzy Problem)**
> "甚至连我自己都说不清楚想要什么……
> 我只知道现在客人一多，服务员就忙不过来，到处都在喊'服务员点菜'。
> 我想弄个像肯德基那样**扫码点餐**的东西，大家自己手机上点，厨房直接做，不用服务员跑来跑去。"

</div>
<div style="font-size: 0.9em;">

### **痛点分析**
1.  **人力瓶颈**: "人肉传输" (服务员) 效率低。
2.  **描述模糊**: 只有一个方向 ("扫码点餐")，没有细节 ("具体有哪些页面？")。

### **AI赋能的软件开发范式**
*   **全能助手**: AI的编程能力远超人类，可以瞬间写出数千行代码。
*   **双刃剑**: 但它稍不留神就会写出一堆“能跑但错误”的代码，甚至搞砸整个项目。
*   **你的任务**: 用专业的**Prompt**和**工程思维**去驾驭它，而不是被它带着跑。

</div>
</div>

<!--
- **类型**: 逐字稿
- **内容**: |
  (2分钟) 我们先来带入一个真实的业务场景。
  假设你有个朋友是一家餐厅老板。他的痛点很明确：生意太好，服务员不够用。
  他想做数字化转型，但作为一个非技术人员，他只能说出“我想要个扫码点餐”。
  至于具体怎么扫？界面长啥样？数据怎么传？他一头雾水。
  这就是现实世界中 99% 的需求状态——**模糊**。
  今天我们的第一个任务，不是写代码，而是让 AI 当我们的**产品经理 (PM)**，帮我们把这个模糊的想法，变成清晰的需求文档。
-->

<!--
- **类型**: 教学设计
- **内容**: |
  ### 教学时间: 2分钟
  ### 环节: 场景引入 (Scenario)
  **模糊需求**: 模拟现实中甲方/老板的常态。
  教育学员：开发者的第一步往往不是 Coding，而是 Clarifying。
-->

<!--
- **类型**: 解释
- **内容**: |
  ### 需求工程：从模糊到精确
  这是软件开发中最昂贵的阶段。代码写错了改起来很快，但**做错了产品**就白忙了。
  
  现实中的需求往往是破碎、模糊的。作为“产品经理”，你的核心价值不在于写代码，而在于**将模糊的业务愿景（我想做个点餐的），翻译成精确的功能列表**。
  你描述得越清晰，AI 这个“超级实习生”干活就越靠谱。
-->

---

## **3.1 第一步：需求分析 (Requirements)**

<div class="columns">
<div>

### **策略：角色扮演 (PM)**
*   **目标**: 定义产品，而不是写代码。
*   **角色**: 赋予 AI **"产品经理"** 视角。
*   **关键点**:
    1.  **场景**: 描述真实用例 (扫码点餐)。
    2.  **流程**: 这里的核心是 "Wait Time" (痛点)。
    3.  **产出**: 要求 Output 是功能清单。

</div>
<div>

### **Prompt (Copy & Paste)**
> "我是一家数字化餐厅老板。
> 请帮我梳理**顾客扫码点餐系统**的核心功能和流程。
> **场景**：顾客用手机打开网页。
> **核心流程**：**浏览菜单 -> 选择菜品 -> 确认下单 -> 查看进度**。
> 请列出核心功能点和用户旅程。"

</div>
</div>

<!--
- **类型**: 逐字稿
- **内容**: |
  (2分钟) 好，现在我们进入第一步：需求分析。
  虽然我们心里大概知道要做“扫码点餐”，但这个想法太粗糙了。
  如果直接让 AI 写代码，它可能会问你：“要不要登录？要不要支付？菜单在哪？”把你问晕。
  所以，我们先不写代码，先让 AI 帮我们“理思路”。
  我们赋予它 **产品经理 (PM)** 的角色，告诉它我们的业务场景（手机网页、点餐、看进度），让它帮我们列出一份详细的功能清单。
  这份清单，就是我们后续开发的航海图。
-->

<!--
- **类型**: 教学设计
- **内容**: |
  ### 教学时间: 2分钟
  ### 环节: 需求分析 (Requirements)
  **角色扮演**: 引入 PM 角色。强调“想清楚再写代码”。
  Prompt 的核心在于 Context (餐厅老板) 和 Output (功能清单)。
-->

<!--
- **类型**: 解释
- **内容**: |
  ### 谋定而后动：需求分析的价值
  很多初学者容易犯的错误是“上来就写代码”。这就像盖房子不画图纸直接砌砖，最后往往要推倒重来。

  在软件工程中，**需求分析 (Requirements Analysis)** 是性价比最高的阶段。
  利用 AI 扮演产品经理，实际上是在进行低成本的**思维沙盘推演**。它能帮你把脑海中模糊的“我想做个..."，具象化为清晰的“功能清单”。
  
  请记住：**代码只是思想的载体**。思想越清晰，代码越简单。
-->

---

## **3.2 需求评审：AI 的分析结果**

<div class="columns">
<div>

### **AI 生成的功能清单**
1.  **用户流程**:
    *   **Home页**: 展示所有菜品列表 (图片+价格)。
    *   **Action**: 点击“下单”按钮。
    *   **Feedback**: 弹窗提示“下单成功，预计等待X分钟”。
2.  **核心痛点解决**:
    *   **电子菜单**: 实时同步，不用跑去看墙上的价目表。
    *   **进度反馈**: 缓解等待焦虑。

</div>
<div>

### **分析 (Analysis)**
*   **完整性**: AI 是否覆盖了"点餐"和"等位"两个环节？
*   **可行性**: 作为一个 Demo，这些功能是写得出来的。
*   **下一步**: 有了这份清单，我们就可以找“架构师”做设计了。

</div>
</div>

<!--
- **类型**: 逐字稿
- **内容**: |
  (3分钟) 收到 AI 的分析报告后，作为产品负责人，我们需要进行**评审 (Review)**。
  请大家重点关注 AI 是否捕捉到了核心痛点。
  比如，它是否自动补全了“等待时间反馈”这个功能？这正是解决“顾客焦虑”的关键。
  初学者常犯的错误是把应用做成简单的“信息展示”（如查价格），而忽略了“业务交互”（如下单、查进度）。
  今天我们要实现的，就是一个包含**数据读取**、**数据提交**和**反馈闭环**的完整 MVP (最小可行性产品)。
-->

<!--
- **类型**: 教学设计
- **内容**: |
  ### 教学时间: 3分钟
  ### 环节: 评审 (Review)
  **Critical Thinking**: 不要盲信 AI。
  引导学员检查 AI 生成的清单是否遗漏了关键的“等位”环节（呼应开头的痛点）。
-->

<!--
- **类型**: 解释
- **内容**: |
  ### 缓解焦虑 (User Pain Points)
  好的软件不仅能干活，还能照顾用户的情绪。
  
  在排队场景中，“未知”是焦虑的根源。增加“等待时间预估”功能，技术实现上并不难，但对**用户体验**的提升是巨大的。
  这就是产品经理思维的价值：发现并解决用户的“痛点”，而不仅仅是堆砌功能。
-->

---

## **3.3 第二步：系统设计 (System Design)**

<div class="columns">
<div>

### **策略：设计优先 (Architect)**
*   **目标**: 确定 API 接口，这是前后端的契约。
*   **关键点**:
    1.  **输入**: 拿着上一步的 PM 需求。
    2.  **要求**: 明确要求定义 API (URL 和 Method)。
    3.  **视觉**: 顺便求一个 UI 草图描述。

</div>
<div>

### **Prompt (Copy & Paste)**
> "作为架构师，请基于上述需求设计系统架构：
> 1. **API 设计**: 需要哪些接口？(明确 URL 和 Method)。
> 2. **数据结构**: 菜单和订单长什么样？(JSON 格式)。
> 3. **UI 设计**: 简述界面布局。"

</div>
</div>

<!--
- **类型**: 逐字稿
- **内容**: |
  (2分钟) 拿到需求清单后，很多初学者的冲动是直接开始写代码。但这时我们要先扮演“架构师”角色。
  我们需要先进行**系统设计**，核心是定义 **API 接口**。
  API 在这里起到了**“法律契约”**的作用。
  一旦我们确定了“查询菜单”的 URL 是什么，返回的 JSON 格式长什么样，前端和后端就可以**解耦**，开始并行开发了。
  后端去思考数据库怎么查，前端去思考页面怎么画，只要大家都遵守这个契约，最后就能完美拼合。
-->

<!--
- **类型**: 教学设计
- **内容**: |
  ### 教学时间: 2分钟
  ### 环节: 架构设计 (System Design)
  **教学目标**: 培养学员的**顶层设计意识**。
  **关键动作**:
  1. **角色切换**: 从关注“用户要什么”(PM) 切换到关注“系统怎么做”(Architect)。
  2. **抽象思维**: 引导学员将具体的业务功能（如“点菜”），映射为抽象的技术接口（如 `POST /order`）。
-->

<!--
- **类型**: 解释
- **内容**: |
  ### 契约式开发 (Contract-Based Development)
  在现代软件工程中，API 设计文档不仅仅是文档，更是**协作的基石**。
  
  它解决了协作中的依赖死锁问题：
  - **传统模式**: 后端写完接口 -> 前端看代码 -> 前端写页面 (串行，效率低)。
  - **契约模式**: **先定义接口** -> 前后端**并行工作** (并行，效率高)。
  
  通过这一步，我们将一个复杂的全栈问题，拆解成了两个相对独立的子问题，这是控制系统复杂度的关键手段。
-->

---

## **3.4 设计评审：前后端契约**

<div class="columns">
<div>

### **AI 生成的 API 列表**
*   `GET /menu` 
    *   返回: `[{"name": "红烧肉", "price": 12, "time": 10}, ...]`
*   `POST /order` 
    *   输入: `{"dish": "红烧肉"}`
    *   返回: `{"status": "success", "wait_time": 10}`
*   `GET /order/status` *(Advanced)*

</div>
<div>

### **分析 (Analysis)**
*   **RESTful**: AI 使用了标准的 GET (查) 和 POST (改)。
*   **字段**: 注意 `time` 字段，这是我们计算倒计时的关键。
*   **契约**: 只要后端按这个写，前端按这个调，大家就能对上号。

</div>
</div>

<!--
- **类型**: 逐字稿
- **内容**: |
  (2分钟) 我们来看看 AI 这位架构师交出的图纸。
  请大家重点检查两个细节：
  第一，**HTTP 动词**用对了吗？`GET` 用于获取菜单，`POST` 用于提交订单。这符合 RESTful 的行业标准。
  第二，**数据完整性**。特别要注意返回的数据里有没有 `time`（制作时间）字段。如果这里漏了，我们后续的“倒计时”功能就成无米之炊了。
  确认无误后，这份 API 列表就成为了我们接下来的“施工标准”。
-->

<!--
- **类型**: 教学设计
- **内容**: |
  ### 教学时间: 2分钟
  ### 环节: 设计评审 (Design Review)
  **教学目标**: 培养学员的**审查能力 (Auditing Capability)**。
  **关键动作**:
  1. **验证标准**: 引导学员检查 AI 生成的接口是否符合 RESTful 规范。
  2. **数据溯源**: 检查 API 返回的数据字段是否足以支撑前端页面的显示需求（如：页面要显示价格，API 就必须返回 price）。
-->

<!--
- **类型**: 解释
- **内容**: |
  ### RESTful：互联网的“语法规则”
  RESTful 听起来很学术，实际上它就是一套 **“动词 + 名词”** 的造句规则。

  - **URL 是名词 (资源)**：代表你要操作的对象。比如 `/menu` (菜单), `/order` (订单)。
  - **Method 是动词 (动作)**：代表你要对它做什么。
    - **GET (读)**: 就像去图书馆**查**书。不会改变书的内容。
    - **POST (写)**: 就像去邮局**寄**信。会产生一个新的包裹（数据）。

  **为什么要遵守它？**
  这就好比大家都说“主谓宾”结构的普通话。哪怕是素未谋面的开发者，看到 `DELETE /order/101` 也能瞬间秒懂它的意思是“删除101号订单”。这种 **“望文生义”** 的特性，极大地降低了沟通成本。
-->

---

## **3.5 第三步：编程实现 (Implementation)**

<div class="columns" style="font-size: 0.7em;">
<div>

### **策略：分工协作 (Coding)**
我们把任务拆成两块：后端和前端。

### **Prompt 1: 后端 (Backend)**
> "请修改 `main.py` 以匹配 API 设计：
> 1. 数据：创建一个包含 `price` 和 `time` 的菜单字典。
> 2. 接口：实现 `GET /menu` 和 `POST /order`。
> 3. 逻辑：下单时记录当前时间。"

### **Prompt 2: 前端 (Frontend)**
> "请写一个 `index.html`：
> 1. `fetch('/menu')` 获取列表并渲染成卡片。
> 2. 点击按钮时 `fetch('/order')` 提交订单。
> 3. 样式：美观的卡片式布局。"

</div>
<div class="align-middle-center">

![配图：程序员指挥AI写代码，屏幕上同时显示Python和HTML代码块](image/2025-12-13-15-05-40.png)

</div>
</div>

<!--
- **类型**: 样式替换
- **版本**: [handout, teacher]
- **查找**: |
    <div>
- **替换**: |
    <div class="styled-div" style="font-size: 0.8em;">
-->

<!--
- **类型**: 逐字稿
- **内容**: |
  (3分钟) 设计图纸完成后，我们进入施工阶段。
  为了保证质量，我们将采用**“分而治之 (Divide and Conquer)”**的策略。
  如果我们试图让 AI 一口气“写个完整的点餐系统”，它很容易顾此失彼。
  所以，我们要像技术总监一样进行调度：
  第一步，指挥**后端工程师 (AI)** 修改 `main.py`，专注于把数据逻辑跑通。
  第二步，指挥**前端工程师 (AI)** 编写 `index.html`，专注于界面交互。
  请大家按照这个顺序，分别发送 Prompt。
-->

<!--
- **类型**: 教学设计
- **内容**: |
  ### 教学时间: 3分钟
  ### 环节: 编程实现 (Implementation)
  **教学目标**: 培养**计算思维中的“分解 (Decomposition)”能力**。
  **策略**:
  1. **认知负荷管理**: 将复杂的全栈开发拆解为两个独立的原子任务，避免学员产生畏难情绪。
  2. **过程控制**: 强调“先后台，再前台”的工程顺序，确保地基稳固后再盖楼。
-->

<!--
- **类型**: 解释
- **内容**: |
  ### 两个世界的对话
  我们需要清晰地认识到，我们在编写两个完全独立的程序：
  
  1.  **`main.py` (服务端)**: 运行在服务器上。它是**大脑**，负责计算和存储。它根本不在乎用户用的是手机还是电脑。
  2.  **`index.html` (客户端)**: 运行在用户的浏览器里。它是**手眼**，负责显示和操作。它根本不知道后台的数据是存在内存里还是数据库里。
  
  它们唯一的交集就是我们刚才定义的 **API URL**。这种彻底的解耦，是现代软件高可维护性的关键。
-->

---

## **3.6 视觉进阶：让 AI 当设计师 (UI Design)**

<div class="columns">
<div>

### **策略：角色赋能 (Design)**
*   **痛点**: 后端开发者的审美通常...不太行。
*   **解法**: 赋予 AI **"资深 UI 设计师"** 的角色。
*   **能力**: AI 熟知色彩心理学、排版原则和现代 CSS 特效。
*   **技巧**: 不要只说“好看”，要用**专业术语** (圆角、阴影、响应式)。

</div>
<div style="font-size: 0.9em;">

### **Prompt (设计驱动，出于练习目的)**
> "现在，请变身为**资深 UI 设计师**。
> 请美化 `index.html`，无需修改逻辑，只优化样式：
> 1. **风格**: 现代简约 (Modern Clean)，使用 Card 布局。
> 2. **配色**: 采用更有食欲的**暖色调** (Warm Palette)。
> 3. **交互**: 按钮和卡片增加**鼠标悬停上浮** (Hover Lift) 效果。
> 4. **适配**: 确保在手机上也能完美显示 (Responsive)。"

</div>
</div>

<!--
- **类型**: 样式替换
- **版本**: [handout, teacher]
- **查找**: |
    <div style="font-size: 0.9em;">
- **替换**: |
    <div style="font-size: 0.7em;">
-->

<!--
- **类型**: 逐字稿
- **内容**: |
  (2分钟) 功能跑通了，接下来我们关注**用户体验**。
  以前，后端开发出的网页往往被戏称为“工程师审美”，既丑又难用。
  但现在，你可以瞬间变身为**设计总监**。
  大家注意看这段 Prompt，我们不再描述逻辑，而是大量使用了设计圈的**行话**：比如“卡片式布局”、“暖色调”、“悬停效果”。
  为什么要用这些词？因为在 AI 的世界里，你使用的语言越专业，它调用的能力就越高级。
-->

<!--
- **类型**: 教学设计
- **内容**: |
  ### 教学时间: 2分钟
  ### 环节: UI美化 (Visual Design)
  **教学目标**: 体验 AI 的**跨学科能力** (从逻辑构建切换到视觉设计)。
  **关键策略**: **领域特定语言 (DSL) 提示法**。
  通过对比“把网页做漂亮点”和使用专业术语（如 Responsive, Hover, Card）的效果差异，让学员领悟 Prompt Engineering 的核心原则：**高质量的输入决定高质量的输出**。
-->

<!--
- **类型**: 解释
- **内容**: |
  ### 为什么“行话”能提升效果？(Context Activation)
  大语言模型 (LLM) 是通过海量互联网数据训练的。
  
  - 当你说“好看”时，这是个模糊概念，AI 可能会随机匹配到 90 年代的“好看”。
  - 当你说 **"Modern Clean"**, **"Card Layout"**, **"Responsive"** 时，这些特定的 token 会**激活**模型中与**现代前端框架** (如 Bootstrap, Tailwind CSS) 相关的权重。
  
  这就像在图书馆里，你只有用准了索引词，才能找到那本最专业的书。
-->

---

## **3.7 代码评审：前后端对接**

<div class="columns">
<div>

### **Python (Backend)**
```python
@app.get("/menu")
def get_menu():
    return menu_data  # 列表

@app.post("/order")
def create_order(item: Item):
    # 记录时间，模拟下单
    return {"status": "ok"}
```

</div>
<div>

### **JavaScript (Frontend)**
```javascript
// Render Menu
fetch('/menu')
  .then(res => res.json())
  .then(data => {
     // Loop through data
     // Create HTML Elements
  });
```

</div>
</div>

<!--
- **类型**: 逐字稿
- **内容**: |
  (5分钟) 代码生成完毕。现在我们要进行最关键的一步：**集成 (Integration)**。
  请大家像侦探一样，重点检查两条“线索”：
  第一，**连接点 (Connection)**：前端 fetch 的地址 (`/menu`) 和后端定义的路由 (`@app.get("/menu")`) 必须一个字符都不差。
  第二，**数据流 (Data Flow)**：后端返回的字典键名（如 `price`），前端在解析时必须用一模一样的名字（`data.price`）。
  只要这两个地方对不上，程序就会立刻罢工。
-->

<!--
- **类型**: 教学设计
- **内容**: |
  ### 教学时间: 5分钟
  ### 环节: 集成验收 (Integration Review)
  **教学目标**: 培养学员的**全链路排查能力**。
  **关键策略**: **关键路径分析 (Critical Path Analysis)**。
  不要只盯着报错看，而是引导学员在脑海中追踪一个点击事件的完整生命周期：`Button Click -> Fetch Request -> API Handler -> JSON Response -> DOM Update`。
-->

<!--
- **类型**: 解释
- **内容**: |
  ### 接口对齐 (Interface Alignment)
  前端和后端就像两个独立运转的精密齿轮，API 接口就是它们的**啮合点**。
  
  这是软件开发中最脆弱的环节。任何微小的偏差（例如：后端叫 `img_url`，前端写成了 `image_url`），都会导致齿轮空转，系统失效。
  这就是为什么在工业界，我们如此强调 API 文档的准确性——它是确保齿轮能咬合在一起的唯一标准。
-->

---

## **4. 遇到拦路虎：跨域 (CORS)**

<div class="columns">
<div>

### **现象**
网页报错：`Access to fetch ... has been blocked by CORS policy`。

### **原因 (安全机制)**
浏览器默认**禁止**网页（前厅）随意访问不同源的服务器（后厨），怕有坏人下毒。

### **解法 (在 FastAPI 端)**
我们要给后厨发“通行证”。
告诉浏览器：这个网页是自己人，放行！

</div>
<div>

```python
# 在 main.py 中增加
from fastapi.middleware.cors import CORSMiddleware

app.add_middleware(
    CORSMiddleware,
    # 允许所有来源的网页访问我
    allow_origins=["*"], 
    allow_methods=["*"],
    allow_headers=["*"],
)
```

</div>
</div>

<!--
- **类型**: 逐字稿
- **内容**: |
  (3分钟) 当大家点击按钮时，可能会发现没有任何反应。如果我们打开浏览器的开发者工具 (F12)，会看到红色的报错信息：`CORS error`。
  请不要慌张，这是 Web 开发中一定会遇到的“拦路虎”。
  这其实是浏览器的**安全机制**在起作用。浏览器有一个非常严格的安全铁律：只有当 协议、域名（或IP）、端口 三者完全一致时，才被认为是“一家人”（同源）。当我们直接双击打开 index.html 文件时，浏览器地址栏会显示 file:///Users/...），因为 file 协议和网页访问后端时的 http 协议不同，浏览器默认认为前端（网页index.html）和后端(http://127.0.0.1:8000)是“陌生人”，禁止互相传递数据。
  解决办法是：我们需要在后端代码里签署一份**“通行协议” (Middleware)**，显式地告诉浏览器：“我允许这个网页来访问我。”
-->

<!--
- **类型**: 教学设计
- **内容**: |
  ### 教学时间: 3分钟
  ### 环节: 错误驱动学习 (Error-Driven Learning)
  **教学策略**: **预设故障 (Planned Failure)**。
  我们故意不提前配置 CORS，让学员先撞墙，亲眼看到报错。
  这种“先报错，再修复”的体验，能让学员深刻理解**浏览器安全边界**的存在，比直接给出完美代码的教学效果好得多。
-->

<!--
- **类型**: 解释
- **内容**: |
  ### 为什么浏览器要“多管闲事”？(The Security Rationale)
  你可能会觉得 CORS 报错很烦，但这实际上是一道**防盗门**。
  
  如果没有这道限制（同源策略）：
  当你登录银行账户后，如果不小心点开了一个**恶意钓鱼网站**，该网站的脚本就可以直接向银行服务器发送请求，读取你的余额甚至转账。
  
  浏览器默认拦截跨域请求，正是为了防止这种“隔空取物”。
  **警示**：我们现在使用 `allow_origins=["*"]` 是为了开发方便（允许所有人访问）。但在生产环境中，必须把 `*` 换成具体的域名，否则就等于把防盗门拆了。
-->

---

## **5. 课堂练习：估算等餐时间 (Wait Time)**

<div class="columns">
<div style="font-size: 0.9em;">

### **Level 1: 静态估算 (Logic)**
*   **需求**: “红烧肉要20分钟，其他菜10分钟。”
*   **Prompt**: "实现 `/eta/{dish}`，如果菜名是'红烧肉'返回20分钟，否则10分钟。"

### **Level 2: 动态倒计时 (Timestamp)**
*   **痛点**: 只有“固定时间”不够，顾客想看倒计时。
*   **目标**: `Remaining = Order + Cooking - Now()`。
*   **Prompt**: "升级系统，记录下单时间。提供 `/order/{id}/status` 接口，返回剩余分钟数。"

</div>
<div>

### **Prompt (设计驱动，出于练习目的)**
> "请升级点餐系统，实现**真实的出餐倒计时**：
> 1. **数据**: 给菜单增加 `time` (红烧肉: 10分钟)。
> 2. **下单**: 记录下单时的系统时间戳。
> 3. **接口**: `GET /order/{id}/status`。
>    **逻辑**: 用 (下单时间+制作时间) 减去 (当前时间)。
>    如果时间没到，返回剩余分钟数；到了，返回'已出餐'。"

</div>
</div>

<!--
- **类型**: 逐字稿
- **内容**: |
  (2分钟) 基础功能完成后，我们要解决最具挑战性的痛点：**缓解等待焦虑**。
  简单地告诉顾客“红烧肉要做20分钟”是不够的。因为10分钟后，他还需要等20分钟吗？不，应该是10分钟。
  这就需要我们的系统具备**时间感**。
  我们需要指挥 AI 做两件事：
  第一，**记住**顾客下单的那一瞬间（记录时间戳）。
  第二，**计算**计划出餐时间（一次性逻辑）。
  第三，**计算**现在距离出餐还有多久（动态逻辑）。
  这标志着我们的程序从简单的“搬运数据”进化到了“处理逻辑”。
-->

<!--
- **类型**: 教学设计
- **内容**: |
  ### 教学时间: 2分钟
  ### 环节: 逻辑进阶 (Logic Advancement)
  **教学目标**: 培养学员区分 **"固定值"** 与 **"流动值"** 的计算思维。
  **关键点**:
  - **一次性计算**: `Finish Time` 在下单瞬间确定后就不再改变（比如 12:30 出餐）。
  - **实时计算**: `Remaining Time` 必须每次根据最新的 `Now()` 重新计算。
  引导学员理解：为什么我们需要在 API 接口里实时计算，而不是把“剩余 10 分钟”这个数字存进数据库（因为它下一秒就变了）。
-->

<!--
- **类型**: 解释
- **内容**: |
  ### 业务逻辑：捕捉流动的时间 (Capturing Time)
  什么是“业务逻辑”？简单的 CRUD 只是搬运数据，而业务逻辑是对数据进行**动态计算**。
  
  在本例中，核心公式是：`剩余时间 = (下单时间 + 制作时长) - Now()`
  
  理解这个公式的关键在于区分 **“静”** 与 **“动”** ：
  1.  **预计完成时间 (Finish Time)**：由 `下单时间 + 制作时长` 算出。一旦下单，这个时刻就是**固定不变**的。
  2.  **Now()**：这是**函数调用**，代表**当前时刻**。它是**流动**的，每次运行代码时都不一样。
  
  用一个“固定的未来”减去“流动的现在”，就得到了不断减少的倒计时。这就是软件模拟现实时间的原理。
-->

---

## **代码解析：时间戳逻辑 (Timestamp)**

<div class="columns">
<div>

### **Level 1 代码 (If-Else)**
```python
if dish_name == "红烧肉":
    return "20分钟"
```

### **Level 2 代码 (Timestamp)**
```python
# 下单时
order_time = datetime.now()

# 查进度时
cooking_time = timedelta(minutes=10)
finish_time = order_time + cooking_time
remaining = finish_time - datetime.now()
```

</div>
<div>

### **分析 (Analysis)**
*   **数学逻辑**: 时间计算 = 小学算术。
    *   `Finish` = `Now()` + `Cooking`
    *   `Left` = `Finish` - `Now()`
*   **Python 工具**:
    *   `datetime`: 获取现在的时刻。
    *   `timedelta`: 表达一段时间 (10分钟)。
*   **结论**: 只要逻辑通顺，AI 就能把公式翻译成代码。

</div>
</div>

<!--
- **类型**: 逐字稿
- **内容**: |
  (2分钟) 我们来看看 AI 写出的这段代码。它用到了两个很关键的词：`datetime` 和 `timedelta`。
  大家可以把 `datetime` 想象成钟表上的一个**点**（时刻，如 10:30），而 `timedelta` 是一把**尺子**（时长，如 20分钟）。
  Python 的强大之处在于，它允许你直接对这两个东西做加减法：**点 + 尺子 = 新的点**。
  比如代码里的 `order_time + cooking_time`，Python 会自动帮你算出出餐的具体时刻。你完全不用操心“59分加1分等于00分”这种复杂的进位问题，AI 和 Python 帮你搞定了一切。
-->

<!--
- **类型**: 教学设计
- **内容**: |
  ### 教学时间: 2分钟
  ### 环节: 代码解析 (Code Walkthrough)
  **教学目标**: 理解 **面向对象编程 (OOP)** 中的时间模型。
  **关键概念**:
  - **时刻 (Point in Time)**: `datetime` 对象。
  - **时长 (Duration)**: `timedelta` 对象。
  **难点突破**: 初学者常混淆两者。通过**“数轴隐喻”**（点与线段）帮助理解：
  - 点 + 线段 = 新点
  - 点 - 点 = 线段
-->

<!--
- **类型**: 解释
- **内容**: |
  ### 为什么不能直接加减数字？(Complexity Encapsulation)
  在现实世界中，时间计算充满陷阱（闰年、跨天、时区）。
  
  如果直接用整数 `1250` 代表 12:50，那么 `1250 + 20` 会变成 `1270`，这是错误的（实际上应该是 13:10）。
  
  Python 的 `datetime` 模块提供了一种**类型安全**的机制。它**封装 (Encapsulate)** 了所有复杂的时间规则，让我们能像做小学数学一样简单地处理时间，且保证结果永远正确。这就是使用标准库的价值。
-->

---

## **6. 闭环：让 AI 自动测试 (Automated Testing)**

<div class="columns">
<div>

### **为什么要自动测试？**
*   **痛点**: 每次改了代码，都要去浏览器点点点，又累又枯燥。
*   **解法**: 让 AI 写一个 **“机器人”** (Python 脚本)，帮我们去自动访问接口。
*   **价值**:
    1.  **快**: 1秒钟测完所有接口。
    2.  **准**: 机器人不会眼花。

</div>
<div style="font-size: 0.9em;">

### **Prompt (Copy & Paste)**
> "请帮我写一个自动化测试脚本 `test_api.py`。
> **目标**: 测试点餐系统的所有接口。
> **工具**: 使用 `requests` 库。
> **测试流程**:
> 1. `GET /menu`: 确认能拿到菜单，且里面有 '红烧肉'。
> 2. `POST /order`: 下单 '红烧肉'，确认状态是成功。
> 3. `POST /order`: 下单 '乱七八糟'，确认状态是失败。"

</div>
</div>

<!--
- **类型**: 样式替换
- **版本**: [handout, teacher]
- **查找**: |
    <div style="font-size: 0.9em;">
- **替换**: |
    <div style="font-size: 0.6em;">
-->

<!--
- **类型**: 逐字稿
- **内容**: |
  (2分钟) 功能做完了，但还有一个隐患。
  以后我们每次修改代码（比如加个新菜），难道都要手动去浏览器里点一遍按钮测试一下吗？这既浪费时间，又容易漏测。
  在软件工程中，我们使用 **自动化测试 (Automated Testing)** 来解决这个问题。
  我们可以让 AI 写一段专门的“质检代码”。它就像一个不知疲倦的**虚拟测试员**，能在1秒钟内把所有接口都测一遍。
  一旦它发现问题，就会立刻报警。这就保证了我们无论怎么改代码，都不会破坏已有的功能。
-->

<!--
- **类型**: 教学设计
- **内容**: |
  ### 教学时间: 2分钟
  ### 环节: 测试 (Testing)
  **教学目标**: 建立 **"工程化质量保障"** 的意识。
  **关键概念**: **回归测试 (Regression Testing)**。
  **教学策略**:
  从“手动测试的不可持续性”切入。引导学员理解：随着系统变大，靠人点是不可能的。必须用代码去管理代码。这是从“业余编程”走向“专业工程”的分水岭。
-->

<!--
- **类型**: 解释
- **内容**: |
  ### 回归测试 (Regression Testing)：防止“捡了芝麻丢西瓜”
  在开发中，最常见的情况不是写不出新功能，而是**写了新功能，把旧功能搞坏了**（这叫“回归”）。
  
  自动化测试脚本就是一道**安全网**。它锁定了系统的预期行为。无论你如何修改内部逻辑，只要测试通过，就说明你的修改是安全的。这赋予了开发者**重构 (Refactor)** 的勇气。
-->

---

## **测试结果分析：解读 AI 的报告**

<div class="columns">
<div>

### **运行测试**
在终端输入：
`python test_api.py`

### **预期结果**
```text
[PASS] GET /menu: 菜单获取成功
[PASS] POST /order (红烧肉): 下单成功
[PASS] POST /order (乱七八糟): 成功拒绝异常点单
All tests passed! 
```
看到全是 **Green/Pass**，就说明你的系统非常健壮！

</div>
<div>

### **分析 (Analysis)**
*   **Requests 库**: 它是 Python 界的“浏览器”。我们用 Python 代码模拟了浏览器的行为。
*   **断言 (Assert)**: 机器人的“判断标准”。
    *   `assert response.status_code == 200`
    *   `assert "红烧肉" in response.text`

</div>
</div>

<!--
- **类型**: 逐字稿
- **内容**: |
  (2分钟) 现在，让我们运行这个脚本。大家看终端里的输出，是不是瞬间刷出了一排绿色的 `[PASS]`？
  这说明我们的系统经受住了考验。
  在这个脚本里，`requests` 库扮演了一个**没有显示器的浏览器 (Headless Browser)**，它在后台快速地向服务器发送请求。
  而代码里的 `assert` 语句，就是我们设定的**质量门禁 (Quality Gate)**。比如“红烧肉的价格必须是20”，如果服务器返回了19，脚本就会立刻报错并拦截。
  这一排绿色的 PASS，就是你能交付给用户的信心来源。
-->

<!--
- **类型**: 教学设计
- **内容**: |
  ### 教学时间: 2分钟
  ### 环节: 结果验证 (Verification)
  **教学目标**: 建立对 **Headless Testing (无头测试)** 的感性认识。
  **教学策略**:
  通过对比“手动点鼠标”和“脚本跑测试”的速度差异（几分钟 vs 几毫秒），让学员直观感受自动化测试的压倒性优势，从而接受这种工程实践。
-->

<!--
- **类型**: 解释
- **内容**: |
  ### 断言 (Assertion)：代码中的逻辑哨兵
  每一句 `assert` 都是对系统行为的一次**强制校验**。
  
  它将模糊的“大概是对的”变成了精确的**二元判断**：要么 True（通过），要么 False（崩溃）。
  在工程实践中，我们遵循 **"Fail Fast" (快速失败)** 原则：宁愿程序在测试阶段崩溃（暴露问题），也不愿让错误的程序带着隐患上线运行。
-->

---

## **6.5 深度思考：HTTP 协议的无状态特性 (Critical Thinking)**

<div class="columns">
<div style="font-size: 0.88em;">

### **现象观察 (Observation)**
在刚才的实验中，大家可能注意到了一个现象：
*   当用户刷新浏览器页面时，之前的下单记录**全部消失**了。
*   服务器无法区分“新用户”与“刚刚下过单的回头客”。

### **技术原理：无状态 (Stateless)**
*   这是 HTTP 协议的核心设计特征，而非 Bug。
*   **设计权衡**: 这种设计让服务器处理请求更轻量、易扩展，但也导致它无法默认维持会话上下文 (Session Context)。

</div>
<div>

### **课程设计意图 (Pedagogical Intent)**
为了降低本节课的认知负荷，我们暂时略过了**数据持久化**层。

真实的企业级应用，必须引入**状态管理 (State Management)** 机制（如数据库 Session 或 Token）来维持用户状态。

这正是我们 **下节课 (Lesson 23: MUD Game)** 将要探讨的核心挑战：如何在无状态的 Web 世界构建连续的交互体验。

</div>
</div>

<!--
- **类型**: 逐字稿
- **内容**: |
  (2分钟) 在课程最后，我要请大家做一个破坏性实验：刷新你的浏览器页面。
  发现了什么？刚才下的单、预计的时间，全部归零了。
  这是 Bug 吗？不，这是 Web 开发中最著名的特性：**HTTP 是无状态的 (Stateless)**。
  就像自动售货机，你买完一瓶水走开，再回来买第二瓶，它并不认识你是刚才那个人。服务器对每一次请求都是“脸盲”的。
  这种“健忘”让服务器能同时服务成千上万的人而不累垮，但也给我们带来了难题：如何让它记住“我是我”？
  这正是我们在下一节课——把 MUD 游戏搬上网时，要解决的核心技术难题：**状态管理**。
-->

<!--
- **类型**: 教学设计
- **内容**: |
  ### 教学时间: 2分钟
  ### 环节: 深度思考 (Critical Thinking)
  **教学目标**: 引导学员理解 **"无状态 (Stateless)"** 的架构权衡。
  **认知冲突**: 通过“刷新即丢失”的现象，打破学员对“程序应该记住我”的直觉预期。
  **承上启下**: 指出当前架构的局限性，自然引出下一节课的高阶主题（数据库与会话管理），激发学习欲望。
-->

<!--
- **类型**: 解释
- **内容**: |
  ### 无状态协议 (Stateless Protocol)：服务器的“健忘症”
  HTTP 协议的设计初衷是**简单**和**可扩展**。
  
  - **无状态**: 服务器处理完一个请求（如点餐），就立刻把这件事“忘掉”，释放内存去服务下一个人。
  - **权衡 (Trade-off)**:
      - **优点**: 服务器负载极低，可以轻松应对百万级并发。
      - **缺点**: 如果需要“连续对话”（如购物、游戏），应用层必须自己想办法“记笔记”（引入 Database 或 Session）。
  
  理解这一点，是你从写“脚本”进阶到写“系统”的关键认知升级。
-->

---

## **7.开发范式重构：从线性到螺旋**

<div class="columns" style="font-size: 0.9em;">
<div>

### **传统开发 (Waterfall)**
*   **流程**: 需求 -> 设计 -> 后端 -> 前端 -> 联调。
*   **痛点**: 线性、僵化。一旦需求变了，全流程都要返工。
*   **思维**: **“甲方验收”思维** (做好了交差)。

### **AI 赋能开发 (Agile + AI)**
*   **流程**: 需求 -> **AI (全栈生成)** -> 验证 -> 修正。
*   **特点**: **大迭代 + 小迭代**。AI 同时搞定前后端。
*   **思维**: **“过程控制”思维** (驾驭 AI，持续微调)。

</div>
<div>

### **为什么要先学后端？**
虽然 AI 能全自动生成，但如果不理解 **API** 和 **JSON**，我们就无法进行 **“质量品控”**。
*   **Lesson 21 (后端)**: 学习“发动机原理”。
*   **Lesson 22 (全栈)**: 学习“驾驶技术”。

### **角色切换**
与 AI 结对编程时，我们需要在不同角色间高频切换：
*   **PM**: 定义需求。
*   **架构师**: 控制接口规范。
*   **QA**: 验收测试。

</div>
</div>

<!--
- **类型**: 逐字稿
- **内容**: |
  (2分钟) 最后，我们来升华一下今天的体验。
  大家发现没有？有了 AI，软件开发的模式变了。
  以前，开发就像**接力赛**（瀑布模型），PM传给架构师，架构师传给后端，后端传给前端，任何一个环节掉链子，整个项目就停摆。
  现在，开发更像是**指挥乐队**。你是那个乐队的灵魂——指挥家。
  你指挥 AI 做需求分析，指挥 AI 做系统设计，指挥 AI (后端乐手) 写 API，指挥 AI (前端乐手) 画界面，指挥 AI (测试乐手) 找 Bug。
  在这个模式下，你不再需要亲自去写文档、敲代码，但你必须懂得**看图纸**（架构设计）和**验房子**（质量验收）。
  这就是 AI 时代的**“超级个体”**开发范式。
-->

<!--
- **类型**: 教学设计
- **内容**: |
  ### 教学时间: 2分钟
  ### 环节: 范式升华 (Paradigm Shift)
  **教学目标**: 引导学员完成**身份认同的转变**。
  从关注语法的 "Code Monkey (码农)" 转变为驾驭 AI 的 **"Software Engineer (软件工程师)"**。
  **核心理念**: **Coding is cheap, Architecture & Verification is expensive.** (代码变得廉价，而架构与验证变得昂贵)。
-->

<!--
- **类型**: 解释
- **内容**: |
  ### 瀑布 vs 螺旋 (Waterfall vs Spiral)
  - **线性开发 (Waterfall)**: 是一种**预测性**流程。假设需求一开始就是完美的，然后按部就班执行。它的风险在于“走到终点才发现路错了”。
  - **螺旋迭代 (Spiral/Agile)**: 是一种**适应性**流程。假设需求是不完美的，通过快速构建原型、验证、反馈、修改，螺旋上升。
  
  AI 的出现极大地降低了 **“试错成本”** ，使得个人开发者也能轻松采用这种高效的工业级开发模式。
-->

---

## **8.AI赋能的Web应用开发过程模型**

<div class="align-center">

![width:1000px](image/2025-12-12-15-18-20.png)

</div>

<!--
- **类型**: 逐字稿
- **内容**: |
  (1分钟) 这张图总结了我们今天的终极心法：**AI 赋能开发的“星系模型”**。
  中间这颗恒星是 **AI 引擎**，它提供源源不断的算力和代码生成能力。
  而我们人类，就像能切换轨道的行星，用提示词来切换轨道完成不同的任务：
  1.  **定义期**: 作为 PM，我们把模糊的需求拆解清晰。
  2.  **设计期**: 作为架构师，我们制定 **“契约” (API)**。这一步至关重要，因为有了契约，AI 就可以**左右互搏**，同时并行生成前端和后端代码，效率倍增。
  3.  **验证期**: 作为 QA，我们进行验收。如果不对，带着报错日志进入下一轮**螺旋迭代**。
-->

<!--
- **类型**: 教学设计
- **内容**: |
  ### 教学时间: 1分钟
  ### 环节: 模型总结 (Model Synthesis)
  **核心隐喻**: **星系模型 (Galaxy Model)**。
  **教学目标**: 形象化地总结“人机协作”的动态关系。
  **关键点**:
  1.  **能量中心**: AI 负责 Execution (写代码)，提供核心动力。
  2.  **轨道控制**: 人类负责 Decision (定需求、定接口、定质量)。
  3.  **并发优势**: 强调图中“生成期”的前后端并行，这是 AI 开发相对于传统开发最大的效率提升点。
-->

<!--
- **类型**: 解释
- **内容**: |
  ### 螺旋模型 (Spiral Model)：AI 时代的最佳实践
  传统软件工程常用“瀑布模型”，试图一次性把事情做对。但在 AI 时代， **“快速试错”** 才是王道。
  
  螺旋模型承认认知的局限性。我们先利用 AI 快速生成一个 MVP（最小可行性产品），验证一下，发现不对立刻修改 Prompt 重新生成。
  AI 将每一圈螺旋的时间从“几周”压缩到了“几分钟”，让 **“持续迭代”** 成为了个人开发者的超能力。
-->

---

## **9.课程小结**

<div class="columns" style="font-size: 0.85em;">
<div>

### **今日成就**
1.  **全栈闭环**: 完整体验了一次 **“从后端 API 到前端 Page”** 的开发全流程。
2.  **API 调用**: 用 `Fetch` 指令打通了前后端的任督二脉。
3.  **工程素养**: 掌握了 CORS 修复与自动化测试，像专业人士一样工作。

### **下节预告**
现在我们有了后端，有了前端，技术地基打好了。
下节课，我们将进入 **“案例拆解”** 环节。
来看看如何把我们在模块2写的 MUD 游戏，变成网游！

</div>
<div>

![配图：左边是单向箭头（线性），右边是螺旋上升箭头（AI迭代），展示开发模式的进化](image/2025-12-13-15-08-45.png)

</div>
</div>

<!--
- **类型**: 样式替换
- **版本**: [handout, teacher]
- **查找**: |
    <div>
- **替换**: |
    <div class="styled-div" style="font-size: 0.7em;">
-->

<!--
- **类型**: 逐字稿
- **内容**: |
  (1分钟) 各位老师，今天我们完成了一次跨越。
  我们不再是在黑框框里写脚本，而是构建了一个完整的**互联网服务**。
  回顾一下我们的武器库：**FastAPI** 是后厨，**Fetch** 是传菜员，**CORS** 是安检门，而 **自动化测试** 是我们的质量卫士。
  掌握了这套组合拳，你们就已经具备了现代全栈开发的基础。
  下节课，我们将迎来本次课程的高潮——**“MUD 游戏重制版”**。
  我们要把模块2里那个只能自己玩的文字游戏，搬到互联网上，加入**状态管理**，让它变成一个真正的多人在线游戏。请大家做好准备！
-->

<!--
- **类型**: 教学设计
- **内容**: |
  ### 教学时间: 1分钟
  ### 环节: 课程结语 (Conclusion)
  **教学目标**: **知识体系化 (Systematization)**。
  将本节课零散的技术点（API, Fetch, CORS, Test）串联成一个完整的 **"全栈开发方法论"**。
  **情感设计**: 通过预告“MUD 游戏 Web 化”，激发学员将所学技能应用于复杂趣味项目的渴望，保持学习动力。
-->

<!--
- **类型**: 解释
- **内容**: |
  ### 全栈思维 (Full-Stack Mindset)
  今天的课程看似涉及很多技术细节，但核心其实是**架构思维**：
  1.  **解耦 (Decoupling)**: 前后端各司其职，互不干扰。
  2.  **契约 (Contract)**: 用 API 规范沟通，降低协作成本。
  3.  **闭环 (Loop)**: 用自动化测试保证质量，形成迭代闭环。
  这种思维方式，不仅适用于写代码，也适用于管理复杂的教学项目。
-->
